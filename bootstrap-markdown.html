<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="description" content="Bootstrap-markdown : Bootstrap plugin for markdown editing">
  <link rel="stylesheet" type="text/css" media="screen" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <style type="text/css">
    .md-editor {
      display: block;
      border: 1px solid #ddd
    }

    .md-editor .md-footer, .md-editor > .md-header {
      display: block;
      padding: 6px 4px;
      background: #f5f5f5
    }

    .md-editor > .md-header {
      margin: 0
    }

    .md-editor > .md-preview {
      background: #fff;
      border-top: 1px dashed #ddd;
      border-bottom: 1px dashed #ddd;
      min-height: 10px;
      overflow: auto
    }

    .md-editor > textarea {
      font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size: 14px;
      outline: 0;
      margin: 0;
      display: block;
      padding: 0;
      width: 100%;
      border: 0;
      border-top: 1px dashed #ddd;
      border-bottom: 1px dashed #ddd;
      border-radius: 0;
      box-shadow: none;
      background: #eee
    }

    .md-editor > textarea:focus {
      box-shadow: none;
      background: #fff
    }

    .md-editor.active {
      border-color: #66afe9;
      outline: 0;
      -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 8px rgba(102, 175, 233, .6);
      box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 8px rgba(102, 175, 233, .6)
    }

    .md-editor .md-controls {
      float: right;
      padding: 3px
    }

    .md-editor .md-controls .md-control {
      right: 5px;
      color: #bebebe;
      padding: 3px 3px 3px 10px
    }

    .md-editor .md-controls .md-control:hover {
      color: #333
    }

    .md-editor.md-fullscreen-mode {
      width: 100%;
      height: 100%;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 99999;
      padding: 60px 30px 15px;
      background: #fff !important;
      border: 0 !important
    }

    .md-editor.md-fullscreen-mode .md-footer {
      display: none
    }

    .md-editor.md-fullscreen-mode .md-input, .md-editor.md-fullscreen-mode .md-preview {
      margin: 0 auto !important;
      height: 100% !important;
      font-size: 20px !important;
      padding: 20px !important;
      color: #999;
      line-height: 1.6em !important;
      resize: none !important;
      box-shadow: none !important;
      background: #fff !important;
      border: 0 !important
    }

    .md-editor.md-fullscreen-mode .md-preview {
      color: #333;
      overflow: auto
    }

    .md-editor.md-fullscreen-mode .md-input:focus, .md-editor.md-fullscreen-mode .md-input:hover {
      color: #333;
      background: #fff !important
    }

    .md-editor.md-fullscreen-mode .md-header {
      background: 0 0;
      text-align: center;
      position: fixed;
      width: 100%;
      top: 20px
    }

    .md-editor.md-fullscreen-mode .btn-group {
      float: none
    }

    .md-editor.md-fullscreen-mode .btn {
      border: 0;
      background: 0 0;
      color: #b3b3b3
    }

    .md-editor.md-fullscreen-mode .btn.active, .md-editor.md-fullscreen-mode .btn:active, .md-editor.md-fullscreen-mode .btn:focus, .md-editor.md-fullscreen-mode .btn:hover {
      box-shadow: none;
      color: #333
    }

    .md-editor.md-fullscreen-mode .md-fullscreen-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      text-align: right;
      z-index: 1002;
      display: block
    }

    .md-editor.md-fullscreen-mode .md-fullscreen-controls a {
      color: #b3b3b3;
      clear: right;
      margin: 10px;
      width: 30px;
      height: 30px;
      text-align: center
    }

    .md-editor.md-fullscreen-mode .md-fullscreen-controls a:hover {
      color: #333;
      text-decoration: none
    }

    .md-editor.md-fullscreen-mode .md-editor {
      height: 100% !important;
      position: relative
    }

    .md-editor .md-fullscreen-controls {
      display: none
    }

    .md-nooverflow {
      overflow: hidden;
      position: fixed;
      width: 100%
    }

    /******************************************************************************* Slate Theme for GitHub Pages by Jason Costello, @jsncostello *******************************************************************************/
    @import url(pygment_trac.css); /******************************************************************************* MeyerWeb Reset *******************************************************************************/
    html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
      margin: 0;
      padding: 0;
      border: 0;
      font: inherit;
      vertical-align: baseline;
    }

    /* HTML5 display-role reset for older browsers */
    article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section {
      display: block;
    }

    ol, ul {
      list-style: none;
    }

    blockquote, q {
    }

    table {
      border-collapse: collapse;
      border-spacing: 0;
    }

    a:focus {
      outline: none;
    }

    /******************************************************************************* Theme Styles *******************************************************************************/
    body {
      box-sizing: border-box;
      color: #373737;
      background: #212121;
      font-size: 16px;
      font-family: 'Myriad Pro', Calibri, Helvetica, Arial, sans-serif;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }

    h1, h2, h3, h4, h5, h6 {
      margin: 10px 0;
      font-weight: 700;
      color: #222222;
      font-family: 'Lucida Grande', 'Calibri', Helvetica, Arial, sans-serif;
      letter-spacing: -1px;
    }

    h1 {
      font-size: 36px;
      font-weight: 700;
    }

    h2 {
      padding-bottom: 10px;
      font-size: 32px;
      background: url('../img/bg_hr.png') repeat-x bottom;
    }

    h3 {
      font-size: 24px;
    }

    h4 {
      font-size: 21px;
    }

    h5 {
      font-size: 18px;
    }

    h6 {
      font-size: 16px;
    }

    p {
      margin: 10px 0 15px 0;
    }

    footer p {
      color: #f2f2f2;
    }

    a {
      text-decoration: none;
      color: #007edf;
      text-shadow: none;
      transition: color 0.5s ease;
      transition: text-shadow 0.5s ease;
      -webkit-transition: color 0.5s ease;
      -webkit-transition: text-shadow 0.5s ease;
      -moz-transition: color 0.5s ease;
      -moz-transition: text-shadow 0.5s ease;
      -o-transition: color 0.5s ease;
      -o-transition: text-shadow 0.5s ease;
      -ms-transition: color 0.5s ease;
      -ms-transition: text-shadow 0.5s ease;
    }

    #main_content a:hover {
      color: #0069ba;
      text-shadow: #0090ff 0px 0px 2px;
    }

    footer a:hover {
      color: #43adff;
      text-shadow: #0090ff 0px 0px 2px;
    }

    em {
      font-style: italic;
    }

    strong {
      font-weight: bold;
    }

    img {
      position: relative;
      margin: 0 auto;
      max-width: 739px;
      padding: 5px;
      margin: 10px 0 10px 0;
      border: 1px solid #ebebeb;
      box-shadow: 0 0 5px #ebebeb;
      -webkit-box-shadow: 0 0 5px #ebebeb;
      -moz-box-shadow: 0 0 5px #ebebeb;
      -o-box-shadow: 0 0 5px #ebebeb;
      -ms-box-shadow: 0 0 5px #ebebeb;
    }

    pre, code {
      width: 100%;
      color: #222;
      background-color: #fff;
      font-family: Monaco, "Bitstream Vera Sans Mono", "Lucida Console", Terminal, monospace;
      font-size: 14px;
      border-radius: 2px;
      -moz-border-radius: 2px;
      -webkit-border-radius: 2px;
    }

    pre {
      width: 100%;
      padding: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, .1);
      overflow: auto;
    }

    code {
      padding: 3px;
      margin: 0 3px;
      box-shadow: 0 0 10px rgba(0, 0, 0, .1);
    }

    pre code {
      display: block;
      box-shadow: none;
    }

    blockquote {
      color: #666;
      margin-bottom: 20px;
      padding: 0 0 0 20px;
      border-left: 3px solid #bbb;
    }

    ul, ol, dl {
      margin-bottom: 15px
    }

    ul li {
      list-style: inside;
      padding-left: 20px;
    }

    ol li {
      list-style: decimal inside;
      padding-left: 20px;
    }

    dl dt {
      font-weight: bold;
    }

    dl dd {
      padding-left: 20px;
      font-style: italic;
    }

    dl p {
      padding-left: 20px;
      font-style: italic;
    }

    hr {
      height: 1px;
      margin-bottom: 5px;
      border: none;
      background: url('../img/bg_hr.png') repeat-x center;
    }

    table {
      border: 1px solid #373737;
      margin-bottom: 20px;
      text-align: left;
    }

    th {
      font-family: 'Lucida Grande', 'Helvetica Neue', Helvetica, Arial, sans-serif;
      padding: 10px;
      background: #373737;
      color: #fff;
    }

    td {
      padding: 10px;
      border: 1px solid #373737;
    }

    form {
      background: #f2f2f2;
      padding: 20px;
    }

    img {
      width: 100%;
      max-width: 100%;
    }

    /******************************************************************************* Full-Width Styles *******************************************************************************/
    .outer {
      width: 100%;
    }

    .inner {
      position: relative;
      max-width: 640px;
      padding: 20px 10px;
      margin: 0 auto;
    }

    #forkme_banner {
      display: block;
      position: absolute;
      top: 0;
      right: 10px;
      z-index: 10;
      padding: 10px 50px 10px 10px;
      color: #fff;
      background: url('../img/blacktocat.png') #0090ff no-repeat 95% 50%;
      font-weight: 700;
      box-shadow: 0 0 10px rgba(0, 0, 0, .5);
      border-bottom-left-radius: 2px;
      border-bottom-right-radius: 2px;
    }

    #header_wrap {
      background: #212121;
      background: -moz-linear-gradient(top, #373737, #212121);
      background: -webkit-linear-gradient(top, #373737, #212121);
      background: -ms-linear-gradient(top, #373737, #212121);
      background: -o-linear-gradient(top, #373737, #212121);
      background: linear-gradient(top, #373737, #212121);
    }

    #header_wrap .inner {
      padding: 50px 10px 30px 10px;
    }

    #project_title {
      margin: 0;
      color: #fff;
      font-size: 42px;
      font-weight: 700;
      text-shadow: #111 0px 0px 10px;
    }

    #project_tagline {
      color: #fff;
      font-size: 24px;
      font-weight: 300;
      background: none;
      text-shadow: #111 0px 0px 10px;
    }

    #downloads {
      position: absolute;
      width: 210px;
      z-index: 10;
      bottom: -40px;
      right: 0;
      height: 70px;
      background: url('../img/icon_download.png') no-repeat 0% 90%;
    }

    .zip_download_link {
      display: block;
      float: right;
      width: 90px;
      height: 70px;
      text-indent: -5000px;
      overflow: hidden;
      background: url(../img/sprite_download.png) no-repeat bottom left;
    }

    .tar_download_link {
      display: block;
      float: right;
      width: 90px;
      height: 70px;
      text-indent: -5000px;
      overflow: hidden;
      background: url(../img/sprite_download.png) no-repeat bottom right;
      margin-left: 10px;
    }

    .zip_download_link:hover {
      background: url(../img/sprite_download.png) no-repeat top left;
    }

    .tar_download_link:hover {
      background: url(../img/sprite_download.png) no-repeat top right;
    }

    #main_content_wrap {
      background: #f2f2f2;
      border-top: 1px solid #111;
      border-bottom: 1px solid #111;
    }

    #main_content {
      padding-top: 40px;
    }

    #footer_wrap {
      background: #212121;
    }

    /******************************************************************************* Small Device Styles *******************************************************************************/
    @media screen and (max-width: 480px) {
      body {
        font-size: 14px;
      }

      #downloads {
        display: none;
      }

      .inner {
        min-width: 320px;
        max-width: 480px;
      }

      #project_title {
        font-size: 32px;
      }

      h1 {
        font-size: 28px;
      }

      h2 {
        font-size: 24px;
      }

      h3 {
        font-size: 21px;
      }

      h4 {
        font-size: 18px;
      }

      h5 {
        font-size: 14px;
      }

      h6 {
        font-size: 12px;
      }

      code, pre {
        min-width: 320px;
        max-width: 480px;
        font-size: 11px;
      }
    }
  </style>
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
  <link rel="shortcut icon" href="img/favicon.png">

  <title>Bootstrap Markdown</title>
</head>

<body>

<!-- HEADER -->
<div id="header_wrap" class="outer">
  <header class="inner">
    <a id="forkme_banner" href="https://github.com/toopay/bootstrap-markdown">View on GitHub</a>

    <h1 id="project_title">Bootstrap Markdown</h1>
    <h2 id="project_tagline">Markdown editing meet Bootstrap</h2>

    <section id="downloads">
      <a class="zip_download_link" href="https://github.com/toopay/bootstrap-markdown/zipball/master">Download this project as a .zip file</a>
      <a class="tar_download_link" href="https://github.com/toopay/bootstrap-markdown/tarball/master">Download this project as a tar.gz file</a>
    </section>
  </header>
</div>

<!-- MAIN CONTENT -->
<div id="main_content_wrap" class="outer">
  <section id="main_content" class="inner">
    <h2>Simple Markdown editing tools that works!</h2>
    <p>
      <strong>Bootstrap-Markdown</strong> designed to be easily integrated with your bootstrap project. It exposes useful API that allow you to fully hook-in into the plugin
    </p>

    <hr>

    <h1>Markup</h1>
    <p>Switch regular textarea within your form into <strong>Bootstrap-Markdown</strong> editor seamlessly by adding
      <code class="prettyprint">data-provide="markdown"</code> attribute</p>

    <!-- MARKUP-TEXTAREA -->
    <div class="well">
      <h5>Code</h5>
      <pre class="prettyprint">&lt;form&gt;
    &lt;input name="title" type="text" placeholder="Title?" /&gt;
    &lt;textarea name="content" data-provide="markdown" rows="10"&gt;&lt;/textarea&gt;
    &lt;label class="checkbox"&gt;
      &lt;input name="publish" type="checkbox"&gt; Publish
    &lt;/label&gt;
    &lt;hr/&gt;
    &lt;button type="submit" class="btn"&gt;Submit&lt;/button&gt;
  &lt;/form&gt; </pre>
    </div>

    <div class="well">
      <h5>Result</h5>
      <form>
        <div class="form-group">
          <input class="form-control" name="title" type="text" placeholder="Title?">
        </div>
        <div class="md-editor" id="1493864799703">
          <div class="md-header btn-toolbar">
            <div class="btn-group">
              <button class="btn-default btn-sm btn" type="button" title="Bold (Ctrl+B)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdBold" data-hotkey="Ctrl+B">
                <span class="glyphicon glyphicon-bold"></span></button>
              <button class="btn-default btn-sm btn" type="button" title="Italic (Ctrl+I)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdItalic" data-hotkey="Ctrl+I">
                <span class="glyphicon glyphicon-italic"></span></button>
              <button class="btn-default btn-sm btn" type="button" title="Heading (Ctrl+H)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdHeading" data-hotkey="Ctrl+H">
                <span class="glyphicon glyphicon-header"></span></button>
            </div>
            <div class="btn-group">
              <button class="btn-default btn-sm btn" type="button" title="URL/Link (Ctrl+L)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdUrl" data-hotkey="Ctrl+L">
                <span class="glyphicon glyphicon-link"></span></button>
              <button class="btn-default btn-sm btn" type="button" title="Image (Ctrl+G)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdImage" data-hotkey="Ctrl+G">
                <span class="glyphicon glyphicon-picture"></span></button>
            </div>
            <div class="btn-group">
              <button class="btn-default btn-sm btn" type="button" title="Unordered List (Ctrl+U)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdList" data-hotkey="Ctrl+U">
                <span class="glyphicon glyphicon-list"></span></button>
              <button class="btn-default btn-sm btn" type="button" title="Ordered List (Ctrl+O)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdListO" data-hotkey="Ctrl+O">
                <span class="glyphicon glyphicon-th-list"></span></button>
              <button class="btn-default btn-sm btn" type="button" title="Code (Ctrl+K)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdCode" data-hotkey="Ctrl+K">
                <span class="glyphicon glyphicon-asterisk"></span></button>
              <button class="btn-default btn-sm btn" type="button" title="Quote (Ctrl+Q)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdQuote" data-hotkey="Ctrl+Q">
                <span class="glyphicon glyphicon-comment"></span></button>
            </div>
            <div class="btn-group">
              <button class="btn-sm btn btn-primary" type="button" title="Preview (Ctrl+P)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdPreview" data-hotkey="Ctrl+P" data-toggle="button">
                <span class="glyphicon glyphicon-search"></span> Preview
              </button>
            </div>
            <div class="md-controls">
              <a class="md-control md-control-fullscreen" href="#"><span class="glyphicon glyphicon-fullscreen"></span></a>
            </div>
          </div>
          <textarea name="content" data-provide="markdown" rows="15" class="md-input" style="resize: none;">### Hello there
How are you?

I have bellow task for you :

Select from this text...
Click the bold on THIS WORD and make THESE ONE italic
Link GOOGLE to google.com
Test to insert image (and try to tab after write the image description)
Test Preview
And ending here... Click "List"

Enjoy!</textarea>
          <div class="md-fullscreen-controls">
            <a href="#" class="exit-fullscreen" title="Exit fullscreen"><span class="glyphicon glyphicon-fullscreen"></span></a>
          </div>
        </div>
        <label class="checkbox"> <input name="publish" type="checkbox"> Publish </label>
        <hr>
        <button type="submit" class="btn">Submit</button>
      </form>
    </div>

    <p>Inline editing with <strong>Bootstrap-Markdown</strong> is done by adding
      <code class="prettyprint">data-provide="markdown-editable"</code> attribute</p>

    <!-- MARKUP-EDITABLE -->
    <div class="well">
      <h5>Code</h5>
      <pre class="prettyprint">&lt;div data-provide="markdown-editable"&gt;
          &lt;h3&gt;This is some editable heading&lt;/h3&gt;
          &lt;p&gt;Well, actually all contents within this "markdown-editable" context is really editable. Just click anywhere!&lt;/p&gt;
&lt;/div&gt;</pre>
    </div>

    <div class="well">
      <h5>Result</h5>
      <div data-provide="markdown-editable">
        <h3>This is some editable heading</h3>
        <p>Well, actually all contents within this "markdown-editable" context is really editable. Just click anywhere!</p>
      </div>
    </div>

    <hr>

    <h1>Usage</h1>
    <p>Beside using above data-attributes, you could call it via code</p>
    <pre class="prettyprint">$("#some-textarea").markdown({autofocus:false,savable:false})</pre>
    <p>Noted that <strong>Bootstrap-Markdown</strong> could be used as a standalone input (without any form). Set
      <code>savable</code> parameter to
      <code>true</code> will do the job. Options can be passed via data attributes or via code. Available options are:
    </p>

    <table class="table table-bordered table-striped">
      <colgroup>
        <col class="span1">
        <col class="span7">
      </colgroup>
      <thead>
      <tr>
        <th>Option Name</th>
        <th>Type</th>
        <th>Description</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td>
          <code>autofocus</code>
        </td>
        <td><code>boolean</code></td>
        <td>Indicates that editor will focused after instantiated. Default to <code>false</code></td>
      </tr>
      <tr>
        <td>
          <code>savable</code>
        </td>
        <td><code>boolean</code></td>
        <td>Indicates that editor will have save button and action. Default to <code>false</code></td>
      </tr>
      <tr>
        <td>
          <code>hideable</code>
        </td>
        <td><code>boolean</code></td>
        <td>If set to <code>true</code> then the editor will be hidden on <code>blur</code> event. Default to
          <code>false</code></td>
      </tr>
      <tr>
        <td>
          <code>width</code>
        </td>
        <td><code>mixed</code></td>
        <td>The editor width. Default to
          <code>inherit</code>. You could supply any numerical value (that will be set as css), or supply valid Bootstrap class (something like
          <code>span2</code>)
        </td>
      </tr>
      <tr>
        <td>
          <code>height</code>
        </td>
        <td><code>mixed</code></td>
        <td>The editor height. Default to <code>inherit</code></td>
      </tr>
      <tr>
        <td>
          <code>resize</code>
        </td>
        <td><code>string</code></td>
        <td>Option to disable or change the resize property, possible values
          <code>none</code>,<code>both</code>,<code>horizontal</code>,<code>vertical</code>. Default
          <code>none</code><br> If this option is enabled, the user will be able to resize the editor and preview screen.<br><br>
          <div class="alert alert-warning">
            <strong>Browser support</strong>
            <p>This is currently only supported on limited browsers. See
              <a href="http://caniuse.com/css-resize" target="_blank">Can you run it: Resize</a> for all supported browsers
            </p>
          </div>
        </td>
      </tr>
      <tr>
        <td>
          <code>iconlibrary</code>
        </td>
        <td><code>string</code></td>
        <td>The icon library to use. Glyphicons (<code>glyph</code>), Font Awesome (<code>fa</code>) and Octicons (<code>octicons</code>) are supported. In order to use Font Awesome properly, you'll need to
          <a href="http://fontawesome.io/get-started/">include Font Awesome stylesheet</a> yourself. Also for use Octicons, follow instructions
          <a href="https://octicons.github.com/usage/">here</a>. Default to <code>glyph</code></td>
      </tr>
      <tr>
        <td>
          <code>language</code>
        </td>
        <td><code>string</code></td>
        <td>Localization setting. Default to <code>en</code></td>
      </tr>

      <tr>
        <td>
          <code>footer</code>
        </td>
        <td><code>mixed</code></td>
        <td>Footer dom. Can be string or callback. Default is empty string</td>
      </tr>

      <tr>
        <td>
          <code>fullscreen</code>
        </td>
        <td><code>object</code></td>
        <td>Contains <code>enable</code> (<code>bool</code>) and <code>icons</code> (<code>object</code>) keys.</td>
      </tr>


      <tr>
        <td>
          <code>hiddenButtons</code>
        </td>
        <td><code>mixed</code></td>
        <td>Array or string of button names to be hidden. Default is empty string</td>
      </tr>

      <tr>
        <td>
          <code>disabledButtons</code>
        </td>
        <td><code>mixed</code></td>
        <td>Array or string of button names to be disabled. Default is empty string</td>
      </tr>


      <tr>
        <td>
          <code>dropZoneOptions</code>
        </td>
        <td><code>object</code></td>
        <td>Enables integration with
          <a href="http://www.dropzonejs.com/">DropZone</a> for allowing file upload/linking via drag&amp;drop. The options are directly passed to the DropZone library. Valid options are described
          <a href="http://www.dropzonejs.com/#configuration">here</a></td>
      </tr>

      </tbody>
    </table>

    <div class="well">
      <h5>Some examples</h5>
      <hr>
      <p>Custom width using <code>data-width="400"</code> attribute</p>
      <div class="md-editor" id="1493864799745" style="display: table;">
        <div class="md-header btn-toolbar">
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Bold (Ctrl+B)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdBold" data-hotkey="Ctrl+B">
              <span class="glyphicon glyphicon-bold"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Italic (Ctrl+I)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdItalic" data-hotkey="Ctrl+I">
              <span class="glyphicon glyphicon-italic"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Heading (Ctrl+H)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdHeading" data-hotkey="Ctrl+H">
              <span class="glyphicon glyphicon-header"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="URL/Link (Ctrl+L)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdUrl" data-hotkey="Ctrl+L">
              <span class="glyphicon glyphicon-link"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Image (Ctrl+G)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdImage" data-hotkey="Ctrl+G">
              <span class="glyphicon glyphicon-picture"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Unordered List (Ctrl+U)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdList" data-hotkey="Ctrl+U">
              <span class="glyphicon glyphicon-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Ordered List (Ctrl+O)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdListO" data-hotkey="Ctrl+O">
              <span class="glyphicon glyphicon-th-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Code (Ctrl+K)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdCode" data-hotkey="Ctrl+K">
              <span class="glyphicon glyphicon-asterisk"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Quote (Ctrl+Q)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdQuote" data-hotkey="Ctrl+Q">
              <span class="glyphicon glyphicon-comment"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-sm btn btn-primary" type="button" title="Preview (Ctrl+P)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdPreview" data-hotkey="Ctrl+P" data-toggle="button">
              <span class="glyphicon glyphicon-search"></span> Preview
            </button>
          </div>
          <div class="md-controls">
            <a class="md-control md-control-fullscreen" href="#"><span class="glyphicon glyphicon-fullscreen"></span></a>
          </div>
        </div>
        <textarea data-provide="markdown" data-width="400" class="md-input" rows="5" style="width: 400px; resize: none;"></textarea>
        <div class="md-fullscreen-controls">
          <a href="#" class="exit-fullscreen" title="Exit fullscreen"><span class="glyphicon glyphicon-fullscreen"></span></a>
        </div>
      </div>
      <br>
      <hr>
      <p>Hidden buttons using <code>data-hidden-buttons="cmdBold"</code> attribute</p>
      <div class="md-editor" id="1493864799748">
        <div class="md-header btn-toolbar">
          <div class="btn-group">
            <button class="btn-default btn-sm btn hidden" type="button" title="Bold (Ctrl+B)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdBold" data-hotkey="Ctrl+B">
              <span class="glyphicon glyphicon-bold"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Italic (Ctrl+I)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdItalic" data-hotkey="Ctrl+I">
              <span class="glyphicon glyphicon-italic"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Heading (Ctrl+H)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdHeading" data-hotkey="Ctrl+H">
              <span class="glyphicon glyphicon-header"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="URL/Link (Ctrl+L)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdUrl" data-hotkey="Ctrl+L">
              <span class="glyphicon glyphicon-link"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Image (Ctrl+G)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdImage" data-hotkey="Ctrl+G">
              <span class="glyphicon glyphicon-picture"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Unordered List (Ctrl+U)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdList" data-hotkey="Ctrl+U">
              <span class="glyphicon glyphicon-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Ordered List (Ctrl+O)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdListO" data-hotkey="Ctrl+O">
              <span class="glyphicon glyphicon-th-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Code (Ctrl+K)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdCode" data-hotkey="Ctrl+K">
              <span class="glyphicon glyphicon-asterisk"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Quote (Ctrl+Q)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdQuote" data-hotkey="Ctrl+Q">
              <span class="glyphicon glyphicon-comment"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-sm btn btn-primary" type="button" title="Preview (Ctrl+P)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdPreview" data-hotkey="Ctrl+P" data-toggle="button">
              <span class="glyphicon glyphicon-search"></span> Preview
            </button>
          </div>
          <div class="md-controls">
            <a class="md-control md-control-fullscreen" href="#"><span class="glyphicon glyphicon-fullscreen"></span></a>
          </div>
        </div>
        <textarea data-provide="markdown" data-hidden-buttons="cmdBold" class="md-input" rows="5" style="resize: none;"></textarea>
        <div class="md-fullscreen-controls">
          <a href="#" class="exit-fullscreen" title="Exit fullscreen"><span class="glyphicon glyphicon-fullscreen"></span></a>
        </div>
      </div>
      <br>
      <hr>
      <p>Hideable on blur using <code>data-hideable="true"</code> attribute</p>
      <div class="md-editor" id="1493864799751">
        <div class="md-header btn-toolbar">
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Bold (Ctrl+B)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdBold" data-hotkey="Ctrl+B">
              <span class="glyphicon glyphicon-bold"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Italic (Ctrl+I)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdItalic" data-hotkey="Ctrl+I">
              <span class="glyphicon glyphicon-italic"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Heading (Ctrl+H)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdHeading" data-hotkey="Ctrl+H">
              <span class="glyphicon glyphicon-header"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="URL/Link (Ctrl+L)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdUrl" data-hotkey="Ctrl+L">
              <span class="glyphicon glyphicon-link"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Image (Ctrl+G)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdImage" data-hotkey="Ctrl+G">
              <span class="glyphicon glyphicon-picture"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Unordered List (Ctrl+U)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdList" data-hotkey="Ctrl+U">
              <span class="glyphicon glyphicon-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Ordered List (Ctrl+O)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdListO" data-hotkey="Ctrl+O">
              <span class="glyphicon glyphicon-th-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Code (Ctrl+K)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdCode" data-hotkey="Ctrl+K">
              <span class="glyphicon glyphicon-asterisk"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Quote (Ctrl+Q)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdQuote" data-hotkey="Ctrl+Q">
              <span class="glyphicon glyphicon-comment"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-sm btn btn-primary" type="button" title="Preview (Ctrl+P)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdPreview" data-hotkey="Ctrl+P" data-toggle="button">
              <span class="glyphicon glyphicon-search"></span> Preview
            </button>
          </div>
          <div class="md-controls">
            <a class="md-control md-control-fullscreen" href="#"><span class="glyphicon glyphicon-fullscreen"></span></a>
          </div>
        </div>
        <textarea data-provide="markdown" data-hideable="true" class="md-input" rows="5" style="resize: none;"></textarea>
        <div class="md-fullscreen-controls">
          <a href="#" class="exit-fullscreen" title="Exit fullscreen"><span class="glyphicon glyphicon-fullscreen"></span></a>
        </div>
      </div>
      <hr>
      <p>Savable using <code>data-savable="true"</code> attribute</p>
      <div class="md-editor" id="1493864799754">
        <div class="md-header btn-toolbar">
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Bold (Ctrl+B)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdBold" data-hotkey="Ctrl+B">
              <span class="glyphicon glyphicon-bold"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Italic (Ctrl+I)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdItalic" data-hotkey="Ctrl+I">
              <span class="glyphicon glyphicon-italic"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Heading (Ctrl+H)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdHeading" data-hotkey="Ctrl+H">
              <span class="glyphicon glyphicon-header"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="URL/Link (Ctrl+L)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdUrl" data-hotkey="Ctrl+L">
              <span class="glyphicon glyphicon-link"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Image (Ctrl+G)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdImage" data-hotkey="Ctrl+G">
              <span class="glyphicon glyphicon-picture"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Unordered List (Ctrl+U)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdList" data-hotkey="Ctrl+U">
              <span class="glyphicon glyphicon-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Ordered List (Ctrl+O)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdListO" data-hotkey="Ctrl+O">
              <span class="glyphicon glyphicon-th-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Code (Ctrl+K)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdCode" data-hotkey="Ctrl+K">
              <span class="glyphicon glyphicon-asterisk"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Quote (Ctrl+Q)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdQuote" data-hotkey="Ctrl+Q">
              <span class="glyphicon glyphicon-comment"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-sm btn btn-primary" type="button" title="Preview (Ctrl+P)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdPreview" data-hotkey="Ctrl+P" data-toggle="button">
              <span class="glyphicon glyphicon-search"></span> Preview
            </button>
          </div>
          <div class="md-controls">
            <a class="md-control md-control-fullscreen" href="#"><span class="glyphicon glyphicon-fullscreen"></span></a>
          </div>
        </div>
        <textarea data-provide="markdown" data-savable="true" class="md-input" rows="5" style="resize: none;"></textarea>
        <div class="md-footer">
          <button class="btn btn-success" data-provider="bootstrap-markdown" data-handler="cmdSave">
            <i class="icon icon-white icon-ok"></i> Save
          </button>
        </div>
        <div class="md-fullscreen-controls">
          <a href="#" class="exit-fullscreen" title="Exit fullscreen"><span class="glyphicon glyphicon-fullscreen"></span></a>
        </div>
      </div>
      <hr>

      <p>Select Font Awesome icons instead of Glyphicons (requires
        <a href="http://fontawesome.io/get-started/">Font Awesome stylesheet</a>) using
        <code>data-iconlibrary="fa"</code></p>
      <div class="md-editor" id="1493864799758">
        <div class="md-header btn-toolbar">
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Bold (Ctrl+B)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdBold" data-hotkey="Ctrl+B">
              <span class="fa fa-bold"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Italic (Ctrl+I)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdItalic" data-hotkey="Ctrl+I">
              <span class="fa fa-italic"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Heading (Ctrl+H)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdHeading" data-hotkey="Ctrl+H">
              <span class="fa fa-header"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="URL/Link (Ctrl+L)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdUrl" data-hotkey="Ctrl+L">
              <span class="fa fa-link"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Image (Ctrl+G)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdImage" data-hotkey="Ctrl+G">
              <span class="fa fa-picture-o"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Unordered List (Ctrl+U)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdList" data-hotkey="Ctrl+U">
              <span class="fa fa-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Ordered List (Ctrl+O)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdListO" data-hotkey="Ctrl+O">
              <span class="fa fa-list-ol"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Code (Ctrl+K)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdCode" data-hotkey="Ctrl+K">
              <span class="fa fa-code"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Quote (Ctrl+Q)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdQuote" data-hotkey="Ctrl+Q">
              <span class="fa fa-quote-left"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-sm btn btn-primary" type="button" title="Preview (Ctrl+P)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdPreview" data-hotkey="Ctrl+P" data-toggle="button">
              <span class="fa fa-search"></span> Preview
            </button>
          </div>
          <div class="md-controls">
            <a class="md-control md-control-fullscreen" href="#"><span class="fa fa-expand"></span></a></div>
        </div>
        <textarea data-provide="markdown" data-iconlibrary="fa" class="md-input" rows="5" style="resize: none;"></textarea>
        <div class="md-fullscreen-controls">
          <a href="#" class="exit-fullscreen" title="Exit fullscreen"><span class="fa fa-compress"></span></a></div>
      </div>
      <hr>
    </div>

    <h3>Events/Hook</h3>
    <p>There are six main events within <strong>Bootstrap-Markdown</strong> lifecycle : <code>onShow</code>,
      <code>onPreview</code>, <code>onChange</code>, <code>onSave</code>, <code>onFocus</code> and
      <code>onBlur</code>. Heres an example to hook into those events via code:</p>

    <div class="well">
      <h5>Code</h5>
      <pre class="prettyprint">$("#target-editor").markdown({
  savable:true,
  onShow: function(e){
    alert("Showing "
      +e.$textarea.prop("tagName").toLowerCase()
      +"#"
      +e.$textarea.attr("id")
      +" as Markdown Editor...")
  },
  onPreview: function(e) {
    var previewContent

    if (e.isDirty()) {
      var originalContent = e.getContent()

      previewContent = "Prepended text here..."
             + "\n"
             + originalContent
             + "\n"
             +"Apended text here..."
    } else {
      previewContent = "Default content"
    }

    return previewContent
  },
  onSave: function(e) {
    alert("Saving '"+e.getContent()+"'...")
  },
  onChange: function(e){
    console.log("Changed!")
  },
  onFocus: function(e) {
    alert("Focus triggered!")
  },
  onBlur: function(e) {
    alert("Blur triggered!")
  }
})</pre>
    </div>

    <div class="well">
      <h5>Result</h5>
      <textarea id="target-editor"></textarea> <br>
      <button id="editor-triger-init" class="btn btn-primary">Transform into Bootstrap-Markdown</button>
    </div>

    <h3>Editor Panel</h3>
    <p>
      <strong>Bootstrap-Markdown</strong> panel could be easily extended to suit your own specific needs. You can just set
      <code>additionalButtons</code> param, with your own buttons group. Heres an example to add button group into editor panel
    </p>

    <div class="well">
      <h5>Code</h5>
      <pre class="prettyprint">$("#target-editor-with-custom-buttons").markdown({
  additionalButtons: [
    [{
          name: "groupCustom",
          data: [{
            name: "cmdBeer",
            toggle: true, // this param only take effect if you load bootstrap.js
            title: "Beer",
            icon: "glyphicon glyphicon-glass",
            callback: function(e){
              // Replace selection with some drinks
              var chunk, cursor,
                  selected = e.getSelection(), content = e.getContent(),
                  drinks = ["Heinekken", "Budweiser",
                            "Iron City", "Amstel Light",
                            "Red Stripe", "Smithwicks",
                            "Westvleteren", "Sierra Nevada",
                            "Guinness", "Corona", "Calsberg"],
                  index = Math.floor((Math.random()*10)+1)


              // Give random drink
              chunk = drinks[index]

              // transform selection and set the cursor into chunked text
              e.replaceSelection(chunk)
              cursor = selected.start

              // Set the cursor
              e.setSelection(cursor,cursor+chunk.length)
            }
          }]
    }]
  ]
})</pre>
    </div>

    <div class="well">
      <h5>Result</h5>
      <div class="md-editor" id="1493864799766">
        <div class="md-header btn-toolbar">
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Bold (Ctrl+B)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdBold" data-hotkey="Ctrl+B">
              <span class="glyphicon glyphicon-bold"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Italic (Ctrl+I)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdItalic" data-hotkey="Ctrl+I">
              <span class="glyphicon glyphicon-italic"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Heading (Ctrl+H)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdHeading" data-hotkey="Ctrl+H">
              <span class="glyphicon glyphicon-header"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="URL/Link (Ctrl+L)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdUrl" data-hotkey="Ctrl+L">
              <span class="glyphicon glyphicon-link"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Image (Ctrl+G)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdImage" data-hotkey="Ctrl+G">
              <span class="glyphicon glyphicon-picture"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Unordered List (Ctrl+U)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdList" data-hotkey="Ctrl+U">
              <span class="glyphicon glyphicon-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Ordered List (Ctrl+O)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdListO" data-hotkey="Ctrl+O">
              <span class="glyphicon glyphicon-th-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Code (Ctrl+K)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdCode" data-hotkey="Ctrl+K">
              <span class="glyphicon glyphicon-asterisk"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Quote (Ctrl+Q)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdQuote" data-hotkey="Ctrl+Q">
              <span class="glyphicon glyphicon-comment"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-sm btn btn-primary" type="button" title="Preview (Ctrl+P)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdPreview" data-hotkey="Ctrl+P" data-toggle="button">
              <span class="glyphicon glyphicon-search"></span> Preview
            </button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Beer" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdBeer" data-hotkey="">
              <span class="glyphicon glyphicon-glass"></span></button>
          </div>
          <div class="md-controls">
            <a class="md-control md-control-fullscreen" href="#"><span class="glyphicon glyphicon-fullscreen"></span></a>
          </div>
        </div>
        <textarea id="target-editor-with-custom-buttons" class="md-input" rows="5" style="resize: none;"></textarea>
        <div class="md-fullscreen-controls">
          <a href="#" class="exit-fullscreen" title="Exit fullscreen"><span class="glyphicon glyphicon-fullscreen"></span></a>
        </div>
      </div>
    </div>

    <p>With robust options and hooks available, you can also tweak the editor to fully suit with your needs. Here is an example to create a twitter input, markdown way...</p>

    <div class="well">
      <h5>Result</h5>
      <div class="md-editor" id="1493864799771">
        <div class="md-header btn-toolbar">
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Bold (Ctrl+B)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdBold" data-hotkey="Ctrl+B">
              <span class="glyphicon glyphicon-bold"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Italic (Ctrl+I)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdItalic" data-hotkey="Ctrl+I">
              <span class="glyphicon glyphicon-italic"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Heading (Ctrl+H)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdHeading" data-hotkey="Ctrl+H">
              <span class="glyphicon glyphicon-header"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="URL/Link (Ctrl+L)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdUrl" data-hotkey="Ctrl+L">
              <span class="glyphicon glyphicon-link"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Image (Ctrl+G)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdImage" data-hotkey="Ctrl+G">
              <span class="glyphicon glyphicon-picture"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Unordered List (Ctrl+U)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdList" data-hotkey="Ctrl+U">
              <span class="glyphicon glyphicon-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Ordered List (Ctrl+O)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdListO" data-hotkey="Ctrl+O">
              <span class="glyphicon glyphicon-th-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Code (Ctrl+K)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdCode" data-hotkey="Ctrl+K">
              <span class="glyphicon glyphicon-asterisk"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Quote (Ctrl+Q)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdQuote" data-hotkey="Ctrl+Q">
              <span class="glyphicon glyphicon-comment"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-sm btn btn-primary hidden" type="button" title="Preview (Ctrl+P)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdPreview" data-hotkey="Ctrl+P" data-toggle="button">
              <span class="glyphicon glyphicon-search"></span> Preview
            </button>
          </div>
          <div class="md-controls">
            <a class="md-control md-control-fullscreen" href="#"><span class="glyphicon glyphicon-fullscreen"></span></a>
          </div>
        </div>
        <textarea id="target-editor-twitter" class="md-input" rows="5" style="resize: none;"></textarea>
        <div class="md-footer">
          <div id="twitter-footer" class="well" style="display:none;"></div>
          <small id="twitter-counter" class="text-success">140 character left</small>
        </div>
        <div class="md-fullscreen-controls">
          <a href="#" class="exit-fullscreen" title="Exit fullscreen"><span class="glyphicon glyphicon-fullscreen"></span></a>
        </div>
      </div>
    </div>

    <h3>Localization</h3>
    <p><strong>Bootstrap-Markdown</strong>
      <code>language</code> option provides a convenient way of retrieving strings in various languages, allowing you to easily support multiple languages within your application.
    </p>

    <p>First, you need to include the language message, for example you can have bellow lines :</p>
    <pre class="prettyprint">;(function($){
  $.fn.markdown.messages['fr'] = {
    'Bold': "Gras",
    'Italic': "Italique",
    'Heading': "Titre",
    'URL/Link': "Insrer un lien HTTP",
    'Image': "Insrer une image",
    'List': "Liste  puces",
    'Preview': "Prvisualiser",
    'strong text': "texte important",
    'emphasized text': "texte soulign",
    'heading text': "texte d'entte",
    'enter link description here': "entrez la description du lien ici",
    'Insert Hyperlink': "Insrez le lien hypertexte",
    'enter image description here': "entrez la description de l'image ici",
    'Insert Image Hyperlink': "Insrez le lien hypertexte de l'image",
    'enter image title here': "entrez le titre de l'image ici",
    'list text here': "texte  puce ici"
  };
}(jQuery))</pre>
    <p>Afterward, just set the <code>language</code> to use defined locale code</p>
    <div class="well">
      <h5>Code</h5>
      <pre class="prettyprint">$("#target-editor-with-custom-language").markdown({language:'fr'})</pre>
    </div>

    <div class="well">
      <h5>Result</h5>
      <div class="md-editor" id="1493864799774">
        <div class="md-header btn-toolbar">
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Gras (Ctrl+B)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdBold" data-hotkey="Ctrl+B">
              <span class="glyphicon glyphicon-bold"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Italique (Ctrl+I)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdItalic" data-hotkey="Ctrl+I">
              <span class="glyphicon glyphicon-italic"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Titre (Ctrl+H)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdHeading" data-hotkey="Ctrl+H">
              <span class="glyphicon glyphicon-header"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Insrer un lien HTTP (Ctrl+L)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdUrl" data-hotkey="Ctrl+L">
              <span class="glyphicon glyphicon-link"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Insrer une image (Ctrl+G)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdImage" data-hotkey="Ctrl+G">
              <span class="glyphicon glyphicon-picture"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-default btn-sm btn" type="button" title="Liste dsordonne (Ctrl+U)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdList" data-hotkey="Ctrl+U">
              <span class="glyphicon glyphicon-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Liste ordonne (Ctrl+O)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdListO" data-hotkey="Ctrl+O">
              <span class="glyphicon glyphicon-th-list"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Code (Ctrl+K)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdCode" data-hotkey="Ctrl+K">
              <span class="glyphicon glyphicon-asterisk"></span></button>
            <button class="btn-default btn-sm btn" type="button" title="Citation (Ctrl+Q)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdQuote" data-hotkey="Ctrl+Q">
              <span class="glyphicon glyphicon-comment"></span></button>
          </div>
          <div class="btn-group">
            <button class="btn-sm btn btn-primary" type="button" title="Prvisualiser (Ctrl+P)" tabindex="-1" data-provider="bootstrap-markdown" data-handler="bootstrap-markdown-cmdPreview" data-hotkey="Ctrl+P" data-toggle="button">
              <span class="glyphicon glyphicon-search"></span> Prvisualiser
            </button>
          </div>
          <div class="md-controls">
            <a class="md-control md-control-fullscreen" href="#"><span class="glyphicon glyphicon-fullscreen"></span></a>
          </div>
        </div>
        <textarea id="target-editor-with-custom-language" class="md-input" rows="5" style="resize: none;"></textarea>
        <div class="md-fullscreen-controls">
          <a href="#" class="exit-fullscreen" title="Exit fullscreen"><span class="glyphicon glyphicon-fullscreen"></span></a>
        </div>
      </div>
    </div>

    <h3>API</h3>
    <p>As you may already notice by now, all hook would passed Editor instance (declared as
      <code>e</code> in all above examples). It means you could easily use its API to interact with the editor for any purposes. Heres the complete list of
      <strong>Bootstrap-Markdown</strong> APIs.</p>

    <table class="table table-bordered table-striped">
      <colgroup>
        <col class="span1">
        <col class="span7">
      </colgroup>
      <thead>
      <tr>
        <th>Method Name</th>
        <th>Description</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td>
          <code>showEditor()</code>
        </td>
        <td>Toggle on the editor visibility</td>
      </tr>
      <tr>
        <td>
          <code>showPreview()</code>
        </td>
        <td>Toggle on the preview visibility</td>
      </tr>
      <tr>
        <td>
          <code>hidePreview()</code>
        </td>
        <td>Toggle off the editor visibility</td>
      </tr>
      <tr>
        <td>
          <code>isDirty()</code>
        </td>
        <td>Check the editor content state, return true if the original content was changed</td>
      </tr>
      <tr>
        <td>
          <code>getContent()</code>
        </td>
        <td>Get the editor content</td>
      </tr>
      <tr>
        <td>
          <code>parseContent()</code>
        </td>
        <td>Get the parsed editor content</td>
      </tr>
      <tr>
        <td>
          <code>setContent(<em>string</em> content)</code>
        </td>
        <td>Set the editor content</td>
      </tr>
      <tr>
        <td>
          <code>findSelection(<em>string</em> words)</code>
        </td>
        <td>Find some words/sentence within the editor and returned selection object(containing word position and other useful information).</td>
      </tr>
      <tr>
        <td>
          <code>getSelection()</code>
        </td>
        <td>Get the current selected chunk of words within the editor.</td>
      </tr>
      <tr>
        <td>
          <code>setSelection(<em>int</em> start, <em>int</em> end)</code>
        </td>
        <td>Tell the editor to select a span of words from <code>start</code> to <code>end</code>.</td>
      </tr>
      <tr>
        <td>
          <code>replaceSelection(<em>string</em> content)</code>
        </td>
        <td>Replace the current selected chunk of words within the editor with any content.</td>
      </tr>
      <tr>
        <td>
          <code>getNextTab()</code>
        </td>
        <td>Get the next tab memory. Returned selection object(containing word position and other useful information).</td>
      </tr>
      <tr>
        <td>
          <code>setNextTab(<em>int</em> start, <em>int</em> end)</code>
        </td>
        <td>Tell the editor to select a span of words from <code>start</code> to <code>end</code> at next
          <code>tab</code> keypress event.
        </td>
      </tr>
      <tr>
        <td>
          <code>enableButtons(<em>string</em> name)</code>
        </td>
        <td>Enabled a button by <code>name</code> that described in <code>buttons</code> or
          <code>additionalButtons</code> arrays. Passing <code>all</code> will enabled all buttons.
        </td>
      </tr>
      <tr>
        <td>
          <code>disableButtons(<em>string</em> name)</code>
        </td>
        <td>Disabled a button by <code>name</code> that described in <code>buttons</code> or
          <code>additionalButtons</code> arrays. Passing <code>all</code> will disabled all buttons.
        </td>
      </tr>
      <tr>
        <td>
          <code>showButtons(<em>string</em> name)</code>
        </td>
        <td>Show a button by <code>name</code> that described in <code>buttons</code> or
          <code>additionalButtons</code> arrays.
        </td>
      </tr>
      <tr>
        <td>
          <code>hideButtons(<em>string</em> name)</code>
        </td>
        <td>Hide a button by <code>name</code> that described in <code>buttons</code> or
          <code>additionalButtons</code> arrays.
        </td>
      </tr>

      </tbody>
    </table>

    <div class="alert alert-info">
      <strong>NOTE</strong>
      <p>Altought the primary purpose of this plugin is to provide Markdown editor, the design is allowing the plugin to be used as a general purpose editor.</p>
      <p>The preview functionalities and html to markdown conversion are provided by 3rd party codes :
        <a href="https://github.com/evilstreak/markdown-js" target="_blank">markdown-js</a>,
        <a href="https://github.com/chjj/marked" target="_blank">marked</a> (default failover if
        <i>markdown-js</i> lib not available) and
        <a href="https://github.com/domchristie/to-markdown" target="_blank">to-markdown</a>. Without them, this plugin would still work and convert the content as-is, so you could easily modify those functionalities yourself via available hooks.
      </p>
      <p>Optionally, you could also support hotkeys by simply including
        <a href="https://github.com/jeresig/jquery.hotkeys" target="_blank">jquery.hotkeys.js</a> (default buttons has already default hotkeys).
      </p>
    </div>
  </section>
</div>

<!-- FOOTER  -->
<div id="footer_wrap" class="outer">
  <footer class="inner">
    <p class="copyright"><strong>Bootstrap-Markdown</strong> maintained by
      <a href="https://github.com/toopay">toopay</a></p>
  </footer>
</div>


<script src="//google-code-prettify.googlecode.com/svn/loader/run_prettify.js" type="text/javascript"></script>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
<script>
  // Released under MIT license
  // Copyright (c) 2009-2010 Dominic Baggott
  // Copyright (c) 2009-2010 Ash Berlin
  // Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)

  (function (expose) {

    /**
     *  class Markdown
     *
     *  Markdown processing in Javascript done right. We have very particular views
     *  on what constitutes 'right' which include:
     *
     *  - produces well-formed HTML (this means that em and strong nesting is
     *    important)
     *
     *  - has an intermediate representation to allow processing of parsed data (We
     *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).
     *
     *  - is easily extensible to add new dialects without having to rewrite the
     *    entire parsing mechanics
     *
     *  - has a good test suite
     *
     *  This implementation fulfills all of these (except that the test suite could
     *  do with expanding to automatically run all the fixtures from other Markdown
     *  implementations.)
     *
     *  ##### Intermediate Representation
     *
     *  *TODO* Talk about this :) Its JsonML, but document the node names we use.
     *
     *  [JsonML]: http://jsonml.org/ "JSON Markup Language"
     **/
    var Markdown = expose.Markdown = function Markdown(dialect) {
      switch (typeof dialect) {
        case "undefined":
          this.dialect = Markdown.dialects.Gruber;
          break;
        case "object":
          this.dialect = dialect;
          break;
        default:
          if (dialect in Markdown.dialects) {
            this.dialect = Markdown.dialects[dialect];
          }
          else {
            throw new Error("Unknown Markdown dialect '" + String(dialect) + "'");
          }
          break;
      }
      this.em_state = [];
      this.strong_state = [];
      this.debug_indent = "";
    };

    /**
     *  parse( markdown, [dialect] ) -> JsonML
     *  - markdown (String): markdown string to parse
     *  - dialect (String | Dialect): the dialect to use, defaults to gruber
     *
     *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.
     **/
    expose.parse = function (source, dialect) {
      // dialect will default if undefined
      var md = new Markdown(dialect);
      return md.toTree(source);
    };

    /**
     *  toHTML( markdown, [dialect]  ) -> String
     *  toHTML( md_tree ) -> String
     *  - markdown (String): markdown string to parse
     *  - md_tree (Markdown.JsonML): parsed markdown tree
     *
     *  Take markdown (either as a string or as a JsonML tree) and run it through
     *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.
     **/
    expose.toHTML = function toHTML(source, dialect, options) {
      var input = expose.toHTMLTree(source, dialect, options);

      return expose.renderJsonML(input);
    };

    /**
     *  toHTMLTree( markdown, [dialect] ) -> JsonML
     *  toHTMLTree( md_tree ) -> JsonML
     *  - markdown (String): markdown string to parse
     *  - dialect (String | Dialect): the dialect to use, defaults to gruber
     *  - md_tree (Markdown.JsonML): parsed markdown tree
     *
     *  Turn markdown into HTML, represented as a JsonML tree. If a string is given
     *  to this function, it is first parsed into a markdown tree by calling
     *  [[parse]].
     **/
    expose.toHTMLTree = function toHTMLTree(input, dialect, options) {
      // convert string input to an MD tree
      if (typeof input === "string") {
        input = this.parse(input, dialect);
      }

      // Now convert the MD tree to an HTML tree

      // remove references from the tree
      var attrs = extract_attr(input),
        refs = {};

      if (attrs && attrs.references) {
        refs = attrs.references;
      }

      var html = convert_tree_to_html(input, refs, options);
      merge_text_nodes(html);
      return html;
    };

    // For Spidermonkey based engines
    function mk_block_toSource() {
      return "Markdown.mk_block( " +
        uneval(this.toString()) +
        ", " +
        uneval(this.trailing) +
        ", " +
        uneval(this.lineNumber) +
        " )";
    }

    // node
    function mk_block_inspect() {
      var util = require('util');
      return "Markdown.mk_block( " +
        util.inspect(this.toString()) +
        ", " +
        util.inspect(this.trailing) +
        ", " +
        util.inspect(this.lineNumber) +
        " )";

    }

    var mk_block = Markdown.mk_block = function (block, trail, line) {
      // Be helpful for default case in tests.
      if (arguments.length == 1) trail = "\n\n";

      var s = new String(block);
      s.trailing = trail;
      // To make it clear its not just a string
      s.inspect = mk_block_inspect;
      s.toSource = mk_block_toSource;

      if (line != undefined)
        s.lineNumber = line;

      return s;
    };

    function count_lines(str) {
      var n = 0, i = -1;
      while (( i = str.indexOf('\n', i + 1) ) !== -1) n++;
      return n;
    }

    // Internal - split source into rough blocks
    Markdown.prototype.split_blocks = function splitBlocks(input, startLine) {
      // [\s\S] matches _anything_ (newline or space)
      var re = /([\s\S]+?)($|\n(?:\s*\n|$)+)/g,
        blocks = [],
        m;

      var line_no = 1;

      if (( m = /^(\s*\n)/.exec(input) ) != null) {
        // skip (but count) leading blank lines
        line_no += count_lines(m[0]);
        re.lastIndex = m[0].length;
      }

      while (( m = re.exec(input) ) !== null) {
        blocks.push(mk_block(m[1], m[2], line_no));
        line_no += count_lines(m[0]);
      }

      return blocks;
    };

    /**
     *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]
     *  - block (String): the block to process
     *  - next (Array): the following blocks
     *
     * Process `block` and return an array of JsonML nodes representing `block`.
     *
     * It does this by asking each block level function in the dialect to process
     * the block until one can. Succesful handling is indicated by returning an
     * array (with zero or more JsonML nodes), failure by a false value.
     *
     * Blocks handlers are responsible for calling [[Markdown#processInline]]
     * themselves as appropriate.
     *
     * If the blocks were split incorrectly or adjacent blocks need collapsing you
     * can adjust `next` in place using shift/splice etc.
     *
     * If any of this default behaviour is not right for the dialect, you can
     * define a `__call__` method on the dialect that will get invoked to handle
     * the block processing.
     */
    Markdown.prototype.processBlock = function processBlock(block, next) {
      var cbs = this.dialect.block,
        ord = cbs.__order__;

      if ("__call__" in cbs) {
        return cbs.__call__.call(this, block, next);
      }

      for (var i = 0; i < ord.length; i++) {
        //D:this.debug( "Testing", ord[i] );
        var res = cbs[ord[i]].call(this, block, next);
        if (res) {
          //D:this.debug("  matched");
          if (!isArray(res) || ( res.length > 0 && !( isArray(res[0]) ) ))
            this.debug(ord[i], "didn't return a proper array");
          //D:this.debug( "" );
          return res;
        }
      }

      // Uhoh! no match! Should we throw an error?
      return [];
    };

    Markdown.prototype.processInline = function processInline(block) {
      return this.dialect.inline.__call__.call(this, String(block));
    };

    /**
     *  Markdown#toTree( source ) -> JsonML
     *  - source (String): markdown source to parse
     *
     *  Parse `source` into a JsonML tree representing the markdown document.
     **/
    // custom_tree means set this.tree to `custom_tree` and restore old value on return
    Markdown.prototype.toTree = function toTree(source, custom_root) {
      var blocks = source instanceof Array ? source : this.split_blocks(source);

      // Make tree a member variable so its easier to mess with in extensions
      var old_tree = this.tree;
      try {
        this.tree = custom_root || this.tree || ["markdown"];

        blocks:
          while (blocks.length) {
            var b = this.processBlock(blocks.shift(), blocks);

            // Reference blocks and the like won't return any content
            if (!b.length) continue blocks;

            this.tree.push.apply(this.tree, b);
          }
        return this.tree;
      }
      finally {
        if (custom_root) {
          this.tree = old_tree;
        }
      }
    };

    // Noop by default
    Markdown.prototype.debug = function () {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(this.debug_indent);
      if (typeof print !== "undefined")
        print.apply(print, args);
      if (typeof console !== "undefined" && typeof console.log !== "undefined")
        console.log.apply(null, args);
    }

    Markdown.prototype.loop_re_over_block = function (re, block, cb) {
      // Dont use /g regexps with this
      var m,
        b = block.valueOf();

      while (b.length && (m = re.exec(b) ) != null) {
        b = b.substr(m[0].length);
        cb.call(this, m);
      }
      return b;
    };

    /**
     * Markdown.dialects
     *
     * Namespace of built-in dialects.
     **/
    Markdown.dialects = {};

    /**
     * Markdown.dialects.Gruber
     *
     * The default dialect that follows the rules set out by John Gruber's
     * markdown.pl as closely as possible. Well actually we follow the behaviour of
     * that script which in some places is not exactly what the syntax web page
     * says.
     **/
    Markdown.dialects.Gruber = {
      block: {
        atxHeader: function atxHeader(block, next) {
          var m = block.match(/^(#{1,6})\s*(.*?)\s*#*\s*(?:\n|$)/);

          if (!m) return undefined;

          var header = ["header", {level: m[1].length}];
          Array.prototype.push.apply(header, this.processInline(m[2]));

          if (m[0].length < block.length)
            next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));

          return [header];
        },

        setextHeader: function setextHeader(block, next) {
          var m = block.match(/^(.*)\n([-=])\2\2+(?:\n|$)/);

          if (!m) return undefined;

          var level = ( m[2] === "=" ) ? 1 : 2;
          var header = ["header", {level: level}, m[1]];

          if (m[0].length < block.length)
            next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));

          return [header];
        },

        code: function code(block, next) {
          // |    Foo
          // |bar
          // should be a code block followed by a paragraph. Fun
          //
          // There might also be adjacent code block to merge.

          var ret = [],
            re = /^(?: {0,3}\t| {4})(.*)\n?/,
            lines;

          // 4 spaces + content
          if (!block.match(re)) return undefined;

          block_search:
            do {
              // Now pull out the rest of the lines
              var b = this.loop_re_over_block(
                re, block.valueOf(), function (m) {
                  ret.push(m[1]);
                });

              if (b.length) {
                // Case alluded to in first comment. push it back on as a new block
                next.unshift(mk_block(b, block.trailing));
                break block_search;
              }
              else if (next.length) {
                // Check the next block - it might be code too
                if (!next[0].match(re)) break block_search;

                // Pull how how many blanks lines follow - minus two to account for .join
                ret.push(block.trailing.replace(/[^\n]/g, '').substring(2));

                block = next.shift();
              }
              else {
                break block_search;
              }
            } while (true);

          return [["code_block", ret.join("\n")]];
        },

        horizRule: function horizRule(block, next) {
          // this needs to find any hr in the block to handle abutting blocks
          var m = block.match(/^(?:([\s\S]*?)\n)?[ \t]*([-_*])(?:[ \t]*\2){2,}[ \t]*(?:\n([\s\S]*))?$/);

          if (!m) {
            return undefined;
          }

          var jsonml = [["hr"]];

          // if there's a leading abutting block, process it
          if (m[1]) {
            jsonml.unshift.apply(jsonml, this.processBlock(m[1], []));
          }

          // if there's a trailing abutting block, stick it into next
          if (m[3]) {
            next.unshift(mk_block(m[3]));
          }

          return jsonml;
        },

        // There are two types of lists. Tight and loose. Tight lists have no whitespace
        // between the items (and result in text just in the <li>) and loose lists,
        // which have an empty line between list items, resulting in (one or more)
        // paragraphs inside the <li>.
        //
        // There are all sorts weird edge cases about the original markdown.pl's
        // handling of lists:
        //
        // * Nested lists are supposed to be indented by four chars per level. But
        //   if they aren't, you can get a nested list by indenting by less than
        //   four so long as the indent doesn't match an indent of an existing list
        //   item in the 'nest stack'.
        //
        // * The type of the list (bullet or number) is controlled just by the
        //    first item at the indent. Subsequent changes are ignored unless they
        //    are for nested lists
        //
        lists: (function () {
          // Use a closure to hide a few variables.
          var any_list = "[*+-]|\\d+\\.",
            bullet_list = /[*+-]/,
            number_list = /\d+\./,
            // Capture leading indent as it matters for determining nested lists.
            is_list_re = new RegExp("^( {0,3})(" + any_list + ")[ \t]+"),
            indent_re = "(?: {0,3}\\t| {4})";

          // TODO: Cache this regexp for certain depths.
          // Create a regexp suitable for matching an li for a given stack depth
          function regex_for_depth(depth) {

            return new RegExp(
              // m[1] = indent, m[2] = list_type
              "(?:^(" + indent_re + "{0," + depth + "} {0,3})(" + any_list + ")\\s+)|" +
              // m[3] = cont
              "(^" + indent_re + "{0," + (depth - 1) + "}[ ]{0,4})"
            );
          }

          function expand_tab(input) {
            return input.replace(/ {0,3}\t/g, "    ");
          }

          // Add inline content `inline` to `li`. inline comes from processInline
          // so is an array of content
          function add(li, loose, inline, nl) {
            if (loose) {
              li.push(["para"].concat(inline));
              return;
            }
            // Hmmm, should this be any block level element or just paras?
            var add_to = li[li.length - 1] instanceof Array && li[li.length - 1][0] == "para"
              ? li[li.length - 1]
              : li;

            // If there is already some content in this list, add the new line in
            if (nl && li.length > 1) inline.unshift(nl);

            for (var i = 0; i < inline.length; i++) {
              var what = inline[i],
                is_str = typeof what == "string";
              if (is_str && add_to.length > 1 && typeof add_to[add_to.length - 1] == "string") {
                add_to[add_to.length - 1] += what;
              }
              else {
                add_to.push(what);
              }
            }
          }

          // contained means have an indent greater than the current one. On
          // *every* line in the block
          function get_contained_blocks(depth, blocks) {

            var re = new RegExp("^(" + indent_re + "{" + depth + "}.*?\\n?)*$"),
              replace = new RegExp("^" + indent_re + "{" + depth + "}", "gm"),
              ret = [];

            while (blocks.length > 0) {
              if (re.exec(blocks[0])) {
                var b = blocks.shift(),
                  // Now remove that indent
                  x = b.replace(replace, "");

                ret.push(mk_block(x, b.trailing, b.lineNumber));
              }
              break;
            }
            return ret;
          }

          // passed to stack.forEach to turn list items up the stack into paras
          function paragraphify(s, i, stack) {
            var list = s.list;
            var last_li = list[list.length - 1];

            if (last_li[1] instanceof Array && last_li[1][0] == "para") {
              return;
            }
            if (i + 1 == stack.length) {
              // Last stack frame
              // Keep the same array, but replace the contents
              last_li.push(["para"].concat(last_li.splice(1)));
            }
            else {
              var sublist = last_li.pop();
              last_li.push(["para"].concat(last_li.splice(1)), sublist);
            }
          }

          // The matcher function
          return function (block, next) {
            var m = block.match(is_list_re);
            if (!m) return undefined;

            function make_list(m) {
              var list = bullet_list.exec(m[2])
                ? ["bulletlist"]
                : ["numberlist"];

              stack.push({list: list, indent: m[1]});
              return list;
            }


            var stack = [], // Stack of lists for nesting.
              list = make_list(m),
              last_li,
              loose = false,
              ret = [stack[0].list],
              i;

            // Loop to search over block looking for inner block elements and loose lists
            loose_search:
              while (true) {
                // Split into lines preserving new lines at end of line
                var lines = block.split(/(?=\n)/);

                // We have to grab all lines for a li and call processInline on them
                // once as there are some inline things that can span lines.
                var li_accumulate = "";

                // Loop over the lines in this block looking for tight lists.
                tight_search:
                  for (var line_no = 0; line_no < lines.length; line_no++) {
                    var nl = "",
                      l = lines[line_no].replace(/^\n/, function (n) {
                        nl = n;
                        return "";
                      });

                    // TODO: really should cache this
                    var line_re = regex_for_depth(stack.length);

                    m = l.match(line_re);
                    //print( "line:", uneval(l), "\nline match:", uneval(m) );

                    // We have a list item
                    if (m[1] !== undefined) {
                      // Process the previous list item, if any
                      if (li_accumulate.length) {
                        add(last_li, loose, this.processInline(li_accumulate), nl);
                        // Loose mode will have been dealt with. Reset it
                        loose = false;
                        li_accumulate = "";
                      }

                      m[1] = expand_tab(m[1]);
                      var wanted_depth = Math.floor(m[1].length / 4) + 1;
                      //print( "want:", wanted_depth, "stack:", stack.length);
                      if (wanted_depth > stack.length) {
                        // Deep enough for a nested list outright
                        //print ( "new nested list" );
                        list = make_list(m);
                        last_li.push(list);
                        last_li = list[1] = ["listitem"];
                      }
                      else {
                        // We aren't deep enough to be strictly a new level. This is
                        // where Md.pl goes nuts. If the indent matches a level in the
                        // stack, put it there, else put it one deeper then the
                        // wanted_depth deserves.
                        var found = false;
                        for (i = 0; i < stack.length; i++) {
                          if (stack[i].indent != m[1]) continue;
                          list = stack[i].list;
                          stack.splice(i + 1);
                          found = true;
                          break;
                        }

                        if (!found) {
                          //print("not found. l:", uneval(l));
                          wanted_depth++;
                          if (wanted_depth <= stack.length) {
                            stack.splice(wanted_depth);
                            //print("Desired depth now", wanted_depth, "stack:", stack.length);
                            list = stack[wanted_depth - 1].list;
                            //print("list:", uneval(list) );
                          }
                          else {
                            //print ("made new stack for messy indent");
                            list = make_list(m);
                            last_li.push(list);
                          }
                        }

                        //print( uneval(list), "last", list === stack[stack.length-1].list );
                        last_li = ["listitem"];
                        list.push(last_li);
                      } // end depth of shenegains
                      nl = "";
                    }

                    // Add content
                    if (l.length > m[0].length) {
                      li_accumulate += nl + l.substr(m[0].length);
                    }
                  } // tight_search

                if (li_accumulate.length) {
                  add(last_li, loose, this.processInline(li_accumulate), nl);
                  // Loose mode will have been dealt with. Reset it
                  loose = false;
                  li_accumulate = "";
                }

                // Look at the next block - we might have a loose list. Or an extra
                // paragraph for the current li
                var contained = get_contained_blocks(stack.length, next);

                // Deal with code blocks or properly nested lists
                if (contained.length > 0) {
                  // Make sure all listitems up the stack are paragraphs
                  forEach(stack, paragraphify, this);

                  last_li.push.apply(last_li, this.toTree(contained, []));
                }

                var next_block = next[0] && next[0].valueOf() || "";

                if (next_block.match(is_list_re) || next_block.match(/^ /)) {
                  block = next.shift();

                  // Check for an HR following a list: features/lists/hr_abutting
                  var hr = this.dialect.block.horizRule(block, next);

                  if (hr) {
                    ret.push.apply(ret, hr);
                    break;
                  }

                  // Make sure all listitems up the stack are paragraphs
                  forEach(stack, paragraphify, this);

                  loose = true;
                  continue loose_search;
                }
                break;
              } // loose_search

            return ret;
          };
        })(),

        blockquote: function blockquote(block, next) {
          if (!block.match(/^>/m))
            return undefined;

          var jsonml = [];

          // separate out the leading abutting block, if any
          if (block[0] != ">") {
            var lines = block.split(/\n/),
              prev = [];

            // keep shifting lines until you find a crotchet
            while (lines.length && lines[0][0] != ">") {
              prev.push(lines.shift());
            }

            // reassemble!
            block = lines.join("\n");
            jsonml.push.apply(jsonml, this.processBlock(prev.join("\n"), []));
          }

          // if the next block is also a blockquote merge it in
          while (next.length && next[0][0] == ">") {
            var b = next.shift();
            block = new String(block + block.trailing + b);
            block.trailing = b.trailing;
          }

          // Strip off the leading "> " and re-process as a block.
          var input = block.replace(/^> ?/gm, ''),
            old_tree = this.tree;
          jsonml.push(this.toTree(input, ["blockquote"]));

          return jsonml;
        },

        referenceDefn: function referenceDefn(block, next) {
          var re = /^\s*\[(.*?)\]:\s*(\S+)(?:\s+(?:(['"])(.*?)\3|\((.*?)\)))?\n?/;
          // interesting matches are [ , ref_id, url, , title, title ]

          if (!block.match(re))
            return undefined;

          // make an attribute node if it doesn't exist
          if (!extract_attr(this.tree)) {
            this.tree.splice(1, 0, {});
          }

          var attrs = extract_attr(this.tree);

          // make a references hash if it doesn't exist
          if (attrs.references === undefined) {
            attrs.references = {};
          }

          var b = this.loop_re_over_block(re, block, function (m) {

            if (m[2] && m[2][0] == '<' && m[2][m[2].length - 1] == '>')
              m[2] = m[2].substring(1, m[2].length - 1);

            var ref = attrs.references[m[1].toLowerCase()] = {
              href: m[2]
            };

            if (m[4] !== undefined)
              ref.title = m[4];
            else if (m[5] !== undefined)
              ref.title = m[5];

          });

          if (b.length)
            next.unshift(mk_block(b, block.trailing));

          return [];
        },

        para: function para(block, next) {
          // everything's a para!
          return [["para"].concat(this.processInline(block))];
        }
      }
    };

    Markdown.dialects.Gruber.inline = {

      __oneElement__: function oneElement(text, patterns_or_re, previous_nodes) {
        var m,
          res,
          lastIndex = 0;

        patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;
        var re = new RegExp("([\\s\\S]*?)(" + (patterns_or_re.source || patterns_or_re) + ")");

        m = re.exec(text);
        if (!m) {
          // Just boring text
          return [text.length, text];
        }
        else if (m[1]) {
          // Some un-interesting text matched. Return that first
          return [m[1].length, m[1]];
        }

        var res;
        if (m[2] in this.dialect.inline) {
          res = this.dialect.inline[m[2]].call(
            this,
            text.substr(m.index), m, previous_nodes || []);
        }
        // Default for now to make dev easier. just slurp special and output it.
        res = res || [m[2].length, m[2]];
        return res;
      },

      __call__: function inline(text, patterns) {

        var out = [],
          res;

        function add(x) {
          //D:self.debug("  adding output", uneval(x));
          if (typeof x == "string" && typeof out[out.length - 1] == "string")
            out[out.length - 1] += x;
          else
            out.push(x);
        }

        while (text.length > 0) {
          res = this.dialect.inline.__oneElement__.call(this, text, patterns, out);
          text = text.substr(res.shift());
          forEach(res, add)
        }

        return out;
      },

      // These characters are intersting elsewhere, so have rules for them so that
      // chunks of plain text blocks don't include them
      "]": function () {
      },
      "}": function () {
      },

      "\\": function escaped(text) {
        // [ length of input processed, node/children to add... ]
        // Only esacape: \ ` * _ { } [ ] ( ) # * + - . !
        if (text.match(/^\\[\\`\*_{}\[\]()#\+.!\-]/))
          return [2, text[1]];
        else
        // Not an esacpe
          return [1, "\\"];
      },

      "![": function image(text) {

        // Unlike images, alt text is plain text only. no other elements are
        // allowed in there

        // ![Alt text](/path/to/img.jpg "Optional title")
        //      1          2            3       4         <--- captures
        var m = text.match(/^!\[(.*?)\][ \t]*\([ \t]*(\S*)(?:[ \t]+(["'])(.*?)\3)?[ \t]*\)/);

        if (m) {
          if (m[2] && m[2][0] == '<' && m[2][m[2].length - 1] == '>')
            m[2] = m[2].substring(1, m[2].length - 1);

          m[2] = this.dialect.inline.__call__.call(this, m[2], /\\/)[0];

          var attrs = {alt: m[1], href: m[2] || ""};
          if (m[4] !== undefined)
            attrs.title = m[4];

          return [m[0].length, ["img", attrs]];
        }

        // ![Alt text][id]
        m = text.match(/^!\[(.*?)\][ \t]*\[(.*?)\]/);

        if (m) {
          // We can't check if the reference is known here as it likely wont be
          // found till after. Check it in md tree->hmtl tree conversion
          return [m[0].length, ["img_ref", {alt: m[1], ref: m[2].toLowerCase(), original: m[0]}]];
        }

        // Just consume the '!['
        return [2, "!["];
      },

      "[": function link(text) {

        var orig = String(text);
        // Inline content is possible inside `link text`
        var res = Markdown.DialectHelpers.inline_until_char.call(this, text.substr(1), ']');

        // No closing ']' found. Just consume the [
        if (!res) return [1, '['];

        var consumed = 1 + res[0],
          children = res[1],
          link,
          attrs;

        // At this point the first [...] has been parsed. See what follows to find
        // out which kind of link we are (reference or direct url)
        text = text.substr(consumed);

        // [link text](/path/to/img.jpg "Optional title")
        //                 1            2       3         <--- captures
        // This will capture up to the last paren in the block. We then pull
        // back based on if there a matching ones in the url
        //    ([here](/url/(test))
        // The parens have to be balanced
        var m = text.match(/^\s*\([ \t]*(\S+)(?:[ \t]+(["'])(.*?)\2)?[ \t]*\)/);
        if (m) {
          var url = m[1];
          consumed += m[0].length;

          if (url && url[0] == '<' && url[url.length - 1] == '>')
            url = url.substring(1, url.length - 1);

          // If there is a title we don't have to worry about parens in the url
          if (!m[3]) {
            var open_parens = 1; // One open that isn't in the capture
            for (var len = 0; len < url.length; len++) {
              switch (url[len]) {
                case '(':
                  open_parens++;
                  break;
                case ')':
                  if (--open_parens == 0) {
                    consumed -= url.length - len;
                    url = url.substring(0, len);
                  }
                  break;
              }
            }
          }

          // Process escapes only
          url = this.dialect.inline.__call__.call(this, url, /\\/)[0];

          attrs = {href: url || ""};
          if (m[3] !== undefined)
            attrs.title = m[3];

          link = ["link", attrs].concat(children);
          return [consumed, link];
        }

        // [Alt text][id]
        // [Alt text] [id]
        m = text.match(/^\s*\[(.*?)\]/);

        if (m) {

          consumed += m[0].length;

          // [links][] uses links as its reference
          attrs = {ref: ( m[1] || String(children) ).toLowerCase(), original: orig.substr(0, consumed)};

          link = ["link_ref", attrs].concat(children);

          // We can't check if the reference is known here as it likely wont be
          // found till after. Check it in md tree->hmtl tree conversion.
          // Store the original so that conversion can revert if the ref isn't found.
          return [consumed, link];
        }

        // [id]
        // Only if id is plain (no formatting.)
        if (children.length == 1 && typeof children[0] == "string") {

          attrs = {ref: children[0].toLowerCase(), original: orig.substr(0, consumed)};
          link = ["link_ref", attrs, children[0]];
          return [consumed, link];
        }

        // Just consume the '['
        return [1, "["];
      },


      "<": function autoLink(text) {
        var m;

        if (( m = text.match(/^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\.[a-zA-Z]+))>/) ) != null) {
          if (m[3]) {
            return [m[0].length, ["link", {href: "mailto:" + m[3]}, m[3]]];

          }
          else if (m[2] == "mailto") {
            return [m[0].length, ["link", {href: m[1]}, m[1].substr("mailto:".length)]];
          }
          else
            return [m[0].length, ["link", {href: m[1]}, m[1]]];
        }

        return [1, "<"];
      },

      "`": function inlineCode(text) {
        // Inline code block. as many backticks as you like to start it
        // Always skip over the opening ticks.
        var m = text.match(/(`+)(([\s\S]*?)\1)/);

        if (m && m[2])
          return [m[1].length + m[2].length, ["inlinecode", m[3]]];
        else {
          // TODO: No matching end code found - warn!
          return [1, "`"];
        }
      },

      "  \n": function lineBreak(text) {
        return [3, ["linebreak"]];
      }

    };

    // Meta Helper/generator method for em and strong handling
    function strong_em(tag, md) {

      var state_slot = tag + "_state",
        other_slot = tag == "strong" ? "em_state" : "strong_state";

      function CloseTag(len) {
        this.len_after = len;
        this.name = "close_" + md;
      }

      return function (text, orig_match) {

        if (this[state_slot][0] == md) {
          // Most recent em is of this type
          //D:this.debug("closing", md);
          this[state_slot].shift();

          // "Consume" everything to go back to the recrusion in the else-block below
          return [text.length, new CloseTag(text.length - md.length)];
        }
        else {
          // Store a clone of the em/strong states
          var other = this[other_slot].slice(),
            state = this[state_slot].slice();

          this[state_slot].unshift(md);

          //D:this.debug_indent += "  ";

          // Recurse
          var res = this.processInline(text.substr(md.length));
          //D:this.debug_indent = this.debug_indent.substr(2);

          var last = res[res.length - 1];

          //D:this.debug("processInline from", tag + ": ", uneval( res ) );

          var check = this[state_slot].shift();
          if (last instanceof CloseTag) {
            res.pop();
            // We matched! Huzzah.
            var consumed = text.length - last.len_after;
            return [consumed, [tag].concat(res)];
          }
          else {
            // Restore the state of the other kind. We might have mistakenly closed it.
            this[other_slot] = other;
            this[state_slot] = state;

            // We can't reuse the processed result as it could have wrong parsing contexts in it.
            return [md.length, md];
          }
        }
      }; // End returned function
    }

    Markdown.dialects.Gruber.inline["**"] = strong_em("strong", "**");
    Markdown.dialects.Gruber.inline["__"] = strong_em("strong", "__");
    Markdown.dialects.Gruber.inline["*"] = strong_em("em", "*");
    Markdown.dialects.Gruber.inline["_"] = strong_em("em", "_");


    // Build default order from insertion order.
    Markdown.buildBlockOrder = function (d) {
      var ord = [];
      for (var i in d) {
        if (i == "__order__" || i == "__call__") continue;
        ord.push(i);
      }
      d.__order__ = ord;
    };

    // Build patterns for inline matcher
    Markdown.buildInlinePatterns = function (d) {
      var patterns = [];

      for (var i in d) {
        // __foo__ is reserved and not a pattern
        if (i.match(/^__.*__$/)) continue;
        var l = i.replace(/([\\.*+?|()\[\]{}])/g, "\\$1")
          .replace(/\n/, "\\n");
        patterns.push(i.length == 1 ? l : "(?:" + l + ")");
      }

      patterns = patterns.join("|");
      d.__patterns__ = patterns;
      //print("patterns:", uneval( patterns ) );

      var fn = d.__call__;
      d.__call__ = function (text, pattern) {
        if (pattern != undefined) {
          return fn.call(this, text, pattern);
        }
        else {
          return fn.call(this, text, patterns);
        }
      };
    };

    Markdown.DialectHelpers = {};
    Markdown.DialectHelpers.inline_until_char = function (text, want) {
      var consumed = 0,
        nodes = [];

      while (true) {
        if (text[consumed] == want) {
          // Found the character we were looking for
          consumed++;
          return [consumed, nodes];
        }

        if (consumed >= text.length) {
          // No closing char found. Abort.
          return null;
        }

        var res = this.dialect.inline.__oneElement__.call(this, text.substr(consumed));
        consumed += res[0];
        // Add any returned nodes.
        nodes.push.apply(nodes, res.slice(1));
      }
    }

    // Helper function to make sub-classing a dialect easier
    Markdown.subclassDialect = function (d) {
      function Block() {
      }

      Block.prototype = d.block;
      function Inline() {
      }

      Inline.prototype = d.inline;

      return {block: new Block(), inline: new Inline()};
    };

    Markdown.buildBlockOrder(Markdown.dialects.Gruber.block);
    Markdown.buildInlinePatterns(Markdown.dialects.Gruber.inline);

    Markdown.dialects.Maruku = Markdown.subclassDialect(Markdown.dialects.Gruber);

    Markdown.dialects.Maruku.processMetaHash = function processMetaHash(meta_string) {
      var meta = split_meta_hash(meta_string),
        attr = {};

      for (var i = 0; i < meta.length; ++i) {
        // id: #foo
        if (/^#/.test(meta[i])) {
          attr.id = meta[i].substring(1);
        }
        // class: .foo
        else if (/^\./.test(meta[i])) {
          // if class already exists, append the new one
          if (attr['class']) {
            attr['class'] = attr['class'] + meta[i].replace(/./, " ");
          }
          else {
            attr['class'] = meta[i].substring(1);
          }
        }
        // attribute: foo=bar
        else if (/\=/.test(meta[i])) {
          var s = meta[i].split(/\=/);
          attr[s[0]] = s[1];
        }
      }

      return attr;
    }

    function split_meta_hash(meta_string) {
      var meta = meta_string.split(""),
        parts = [""],
        in_quotes = false;

      while (meta.length) {
        var letter = meta.shift();
        switch (letter) {
          case " " :
            // if we're in a quoted section, keep it
            if (in_quotes) {
              parts[parts.length - 1] += letter;
            }
            // otherwise make a new part
            else {
              parts.push("");
            }
            break;
          case "'" :
          case '"' :
            // reverse the quotes and move straight on
            in_quotes = !in_quotes;
            break;
          case "\\" :
            // shift off the next letter to be used straight away.
            // it was escaped so we'll keep it whatever it is
            letter = meta.shift();
          default :
            parts[parts.length - 1] += letter;
            break;
        }
      }

      return parts;
    }

    Markdown.dialects.Maruku.block.document_meta = function document_meta(block, next) {
      // we're only interested in the first block
      if (block.lineNumber > 1) return undefined;

      // document_meta blocks consist of one or more lines of `Key: Value\n`
      if (!block.match(/^(?:\w+:.*\n)*\w+:.*$/)) return undefined;

      // make an attribute node if it doesn't exist
      if (!extract_attr(this.tree)) {
        this.tree.splice(1, 0, {});
      }

      var pairs = block.split(/\n/);
      for (p in pairs) {
        var m = pairs[p].match(/(\w+):\s*(.*)$/),
          key = m[1].toLowerCase(),
          value = m[2];

        this.tree[1][key] = value;
      }

      // document_meta produces no content!
      return [];
    };

    Markdown.dialects.Maruku.block.block_meta = function block_meta(block, next) {
      // check if the last line of the block is an meta hash
      var m = block.match(/(^|\n) {0,3}\{:\s*((?:\\\}|[^\}])*)\s*\}$/);
      if (!m) return undefined;

      // process the meta hash
      var attr = this.dialect.processMetaHash(m[2]);

      var hash;

      // if we matched ^ then we need to apply meta to the previous block
      if (m[1] === "") {
        var node = this.tree[this.tree.length - 1];
        hash = extract_attr(node);

        // if the node is a string (rather than JsonML), bail
        if (typeof node === "string") return undefined;

        // create the attribute hash if it doesn't exist
        if (!hash) {
          hash = {};
          node.splice(1, 0, hash);
        }

        // add the attributes in
        for (a in attr) {
          hash[a] = attr[a];
        }

        // return nothing so the meta hash is removed
        return [];
      }

      // pull the meta hash off the block and process what's left
      var b = block.replace(/\n.*$/, ""),
        result = this.processBlock(b, []);

      // get or make the attributes hash
      hash = extract_attr(result[0]);
      if (!hash) {
        hash = {};
        result[0].splice(1, 0, hash);
      }

      // attach the attributes to the block
      for (a in attr) {
        hash[a] = attr[a];
      }

      return result;
    };

    Markdown.dialects.Maruku.block.definition_list = function definition_list(block, next) {
      // one or more terms followed by one or more definitions, in a single block
      var tight = /^((?:[^\s:].*\n)+):\s+([\s\S]+)$/,
        list = ["dl"],
        i;

      // see if we're dealing with a tight or loose block
      if (( m = block.match(tight) )) {
        // pull subsequent tight DL blocks out of `next`
        var blocks = [block];
        while (next.length && tight.exec(next[0])) {
          blocks.push(next.shift());
        }

        for (var b = 0; b < blocks.length; ++b) {
          var m = blocks[b].match(tight),
            terms = m[1].replace(/\n$/, "").split(/\n/),
            defns = m[2].split(/\n:\s+/);

          // print( uneval( m ) );

          for (i = 0; i < terms.length; ++i) {
            list.push(["dt", terms[i]]);
          }

          for (i = 0; i < defns.length; ++i) {
            // run inline processing over the definition
            list.push(["dd"].concat(this.processInline(defns[i].replace(/(\n)\s+/, "$1"))));
          }
        }
      }
      else {
        return undefined;
      }

      return [list];
    };

    Markdown.dialects.Maruku.inline["{:"] = function inline_meta(text, matches, out) {
      if (!out.length) {
        return [2, "{:"];
      }

      // get the preceeding element
      var before = out[out.length - 1];

      if (typeof before === "string") {
        return [2, "{:"];
      }

      // match a meta hash
      var m = text.match(/^\{:\s*((?:\\\}|[^\}])*)\s*\}/);

      // no match, false alarm
      if (!m) {
        return [2, "{:"];
      }

      // attach the attributes to the preceeding element
      var meta = this.dialect.processMetaHash(m[1]),
        attr = extract_attr(before);

      if (!attr) {
        attr = {};
        before.splice(1, 0, attr);
      }

      for (var k in meta) {
        attr[k] = meta[k];
      }

      // cut out the string and replace it with nothing
      return [m[0].length, ""];
    };

    Markdown.buildBlockOrder(Markdown.dialects.Maruku.block);
    Markdown.buildInlinePatterns(Markdown.dialects.Maruku.inline);

    var isArray = Array.isArray || function (obj) {
        return Object.prototype.toString.call(obj) == '[object Array]';
      };

    var forEach;
    // Don't mess with Array.prototype. Its not friendly
    if (Array.prototype.forEach) {
      forEach = function (arr, cb, thisp) {
        return arr.forEach(cb, thisp);
      };
    }
    else {
      forEach = function (arr, cb, thisp) {
        for (var i = 0; i < arr.length; i++) {
          cb.call(thisp || arr, arr[i], i, arr);
        }
      }
    }

    function extract_attr(jsonml) {
      return isArray(jsonml)
      && jsonml.length > 1
      && typeof jsonml[1] === "object"
      && !( isArray(jsonml[1]) )
        ? jsonml[1]
        : undefined;
    }


    /**
     *  renderJsonML( jsonml[, options] ) -> String
     *  - jsonml (Array): JsonML array to render to XML
     *  - options (Object): options
     *
     *  Converts the given JsonML into well-formed XML.
     *
     *  The options currently understood are:
     *
     *  - root (Boolean): wether or not the root node should be included in the
     *    output, or just its children. The default `false` is to not include the
     *    root itself.
     */
    expose.renderJsonML = function (jsonml, options) {
      options = options || {};
      // include the root element in the rendered output?
      options.root = options.root || false;

      var content = [];

      if (options.root) {
        content.push(render_tree(jsonml));
      }
      else {
        jsonml.shift(); // get rid of the tag
        if (jsonml.length && typeof jsonml[0] === "object" && !( jsonml[0] instanceof Array )) {
          jsonml.shift(); // get rid of the attributes
        }

        while (jsonml.length) {
          content.push(render_tree(jsonml.shift()));
        }
      }

      return content.join("\n\n");
    };

    function escapeHTML(text) {
      return text.replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function render_tree(jsonml) {
      // basic case
      if (typeof jsonml === "string") {
        return escapeHTML(jsonml);
      }

      var tag = jsonml.shift(),
        attributes = {},
        content = [];

      if (jsonml.length && typeof jsonml[0] === "object" && !( jsonml[0] instanceof Array )) {
        attributes = jsonml.shift();
      }

      while (jsonml.length) {
        content.push(arguments.callee(jsonml.shift()));
      }

      var tag_attrs = "";
      for (var a in attributes) {
        tag_attrs += " " + a + '="' + escapeHTML(attributes[a]) + '"';
      }

      // be careful about adding whitespace here for inline elements
      if (tag == "img" || tag == "br" || tag == "hr") {
        return "<" + tag + tag_attrs + "/>";
      }
      else {
        return "<" + tag + tag_attrs + ">" + content.join("") + "</" + tag + ">";
      }
    }

    function convert_tree_to_html(tree, references, options) {
      var i;
      options = options || {};

      // shallow clone
      var jsonml = tree.slice(0);

      if (typeof options.preprocessTreeNode === "function") {
        jsonml = options.preprocessTreeNode(jsonml, references);
      }

      // Clone attributes if they exist
      var attrs = extract_attr(jsonml);
      if (attrs) {
        jsonml[1] = {};
        for (i in attrs) {
          jsonml[1][i] = attrs[i];
        }
        attrs = jsonml[1];
      }

      // basic case
      if (typeof jsonml === "string") {
        return jsonml;
      }

      // convert this node
      switch (jsonml[0]) {
        case "header":
          jsonml[0] = "h" + jsonml[1].level;
          delete jsonml[1].level;
          break;
        case "bulletlist":
          jsonml[0] = "ul";
          break;
        case "numberlist":
          jsonml[0] = "ol";
          break;
        case "listitem":
          jsonml[0] = "li";
          break;
        case "para":
          jsonml[0] = "p";
          break;
        case "markdown":
          jsonml[0] = "html";
          if (attrs) delete attrs.references;
          break;
        case "code_block":
          jsonml[0] = "pre";
          i = attrs ? 2 : 1;
          var code = ["code"];
          code.push.apply(code, jsonml.splice(i));
          jsonml[i] = code;
          break;
        case "inlinecode":
          jsonml[0] = "code";
          break;
        case "img":
          jsonml[1].src = jsonml[1].href;
          delete jsonml[1].href;
          break;
        case "linebreak":
          jsonml[0] = "br";
          break;
        case "link":
          jsonml[0] = "a";
          break;
        case "link_ref":
          jsonml[0] = "a";

          // grab this ref and clean up the attribute node
          var ref = references[attrs.ref];

          // if the reference exists, make the link
          if (ref) {
            delete attrs.ref;

            // add in the href and title, if present
            attrs.href = ref.href;
            if (ref.title) {
              attrs.title = ref.title;
            }

            // get rid of the unneeded original text
            delete attrs.original;
          }
          // the reference doesn't exist, so revert to plain text
          else {
            return attrs.original;
          }
          break;
        case "img_ref":
          jsonml[0] = "img";

          // grab this ref and clean up the attribute node
          var ref = references[attrs.ref];

          // if the reference exists, make the link
          if (ref) {
            delete attrs.ref;

            // add in the href and title, if present
            attrs.src = ref.href;
            if (ref.title) {
              attrs.title = ref.title;
            }

            // get rid of the unneeded original text
            delete attrs.original;
          }
          // the reference doesn't exist, so revert to plain text
          else {
            return attrs.original;
          }
          break;
      }

      // convert all the children
      i = 1;

      // deal with the attribute node, if it exists
      if (attrs) {
        // if there are keys, skip over it
        for (var key in jsonml[1]) {
          i = 2;
        }
        // if there aren't, remove it
        if (i === 1) {
          jsonml.splice(i, 1);
        }
      }

      for (; i < jsonml.length; ++i) {
        jsonml[i] = arguments.callee(jsonml[i], references, options);
      }

      return jsonml;
    }


    // merges adjacent text nodes into a single node
    function merge_text_nodes(jsonml) {
      // skip the tag name and attribute hash
      var i = extract_attr(jsonml) ? 2 : 1;

      while (i < jsonml.length) {
        // if it's a string check the next item too
        if (typeof jsonml[i] === "string") {
          if (i + 1 < jsonml.length && typeof jsonml[i + 1] === "string") {
            // merge the second string into the first and remove it
            jsonml[i] += jsonml.splice(i + 1, 1)[0];
          }
          else {
            ++i;
          }
        }
        // if it's not a string recurse
        else {
          arguments.callee(jsonml[i]);
          ++i;
        }
      }
    }

  })((function () {
    if (typeof exports === "undefined") {
      window.markdown = {};
      return window.markdown;
    }
    else {
      return exports;
    }
  })());
</script>
<script>
  /*
   * to-markdown - an HTML to Markdown converter
   *
   * Copyright 2011, Dom Christie
   * Licenced under the MIT licence
   *
   */

  var toMarkdown = function (string) {

    var ELEMENTS = [
      {
        patterns: 'p',
        replacement: function (str, attrs, innerHTML) {
          return innerHTML ? '\n\n' + innerHTML + '\n' : '';
        }
      },
      {
        patterns: 'br',
        type: 'void',
        replacement: '\n'
      },
      {
        patterns: 'h([1-6])',
        replacement: function (str, hLevel, attrs, innerHTML) {
          var hPrefix = '';
          for (var i = 0; i < hLevel; i++) {
            hPrefix += '#';
          }
          return '\n\n' + hPrefix + ' ' + innerHTML + '\n';
        }
      },
      {
        patterns: 'hr',
        type: 'void',
        replacement: '\n\n* * *\n'
      },
      {
        patterns: 'a',
        replacement: function (str, attrs, innerHTML) {
          var href = attrs.match(attrRegExp('href')),
            title = attrs.match(attrRegExp('title'));
          return href ? '[' + innerHTML + ']' + '(' + href[1] + (title && title[1] ? ' "' + title[1] + '"' : '') + ')' : str;
        }
      },
      {
        patterns: ['b', 'strong'],
        replacement: function (str, attrs, innerHTML) {
          return innerHTML ? '**' + innerHTML + '**' : '';
        }
      },
      {
        patterns: ['i', 'em'],
        replacement: function (str, attrs, innerHTML) {
          return innerHTML ? '_' + innerHTML + '_' : '';
        }
      },
      {
        patterns: 'code',
        replacement: function (str, attrs, innerHTML) {
          return innerHTML ? '`' + innerHTML + '`' : '';
        }
      },
      {
        patterns: 'img',
        type: 'void',
        replacement: function (str, attrs, innerHTML) {
          var src = attrs.match(attrRegExp('src')),
            alt = attrs.match(attrRegExp('alt')),
            title = attrs.match(attrRegExp('title'));
          return '![' + (alt && alt[1] ? alt[1] : '') + ']' + '(' + src[1] + (title && title[1] ? ' "' + title[1] + '"' : '') + ')';
        }
      }
    ];

    for (var i = 0, len = ELEMENTS.length; i < len; i++) {
      if (typeof ELEMENTS[i].patterns === 'string') {
        string = replaceEls(string, {tag: ELEMENTS[i].patterns, replacement: ELEMENTS[i].replacement, type: ELEMENTS[i].type});
      }
      else {
        for (var j = 0, pLen = ELEMENTS[i].patterns.length; j < pLen; j++) {
          string = replaceEls(string, {tag: ELEMENTS[i].patterns[j], replacement: ELEMENTS[i].replacement, type: ELEMENTS[i].type});
        }
      }
    }

    function replaceEls(html, elProperties) {
      var pattern = elProperties.type === 'void' ? '<' + elProperties.tag + '\\b([^>]*)\\/?>' : '<' + elProperties.tag + '\\b([^>]*)>([\\s\\S]*?)<\\/' + elProperties.tag + '>',
        regex = new RegExp(pattern, 'gi'),
        markdown = '';
      if (typeof elProperties.replacement === 'string') {
        markdown = html.replace(regex, elProperties.replacement);
      }
      else {
        markdown = html.replace(regex, function (str, p1, p2, p3) {
          return elProperties.replacement.call(this, str, p1, p2, p3);
        });
      }
      return markdown;
    }

    function attrRegExp(attr) {
      return new RegExp(attr + '\\s*=\\s*["\']?([^"\']*)["\']?', 'i');
    }

    // Pre code blocks

    string = string.replace(/<pre\b[^>]*>`([\s\S]*)`<\/pre>/gi, function (str, innerHTML) {
      innerHTML = innerHTML.replace(/^\t+/g, '  '); // convert tabs to spaces (you know it makes sense)
      innerHTML = innerHTML.replace(/\n/g, '\n    ');
      return '\n\n    ' + innerHTML + '\n';
    });

    // Lists

    // Escape numbers that could trigger an ol
    // If there are more than three spaces before the code, it would be in a pre tag
    // Make sure we are escaping the period not matching any character
    string = string.replace(/^(\s{0,3}\d+)\. /g, '$1\\. ');

    // Converts lists that have no child lists (of same type) first, then works it's way up
    var noChildrenRegex = /<(ul|ol)\b[^>]*>(?:(?!<ul|<ol)[\s\S])*?<\/\1>/gi;
    while (string.match(noChildrenRegex)) {
      string = string.replace(noChildrenRegex, function (str) {
        return replaceLists(str);
      });
    }

    function replaceLists(html) {

      html = html.replace(/<(ul|ol)\b[^>]*>([\s\S]*?)<\/\1>/gi, function (str, listType, innerHTML) {
        var lis = innerHTML.split('</li>');
        lis.splice(lis.length - 1, 1);

        for (i = 0, len = lis.length; i < len; i++) {
          if (lis[i]) {
            var prefix = (listType === 'ol') ? (i + 1) + ".  " : "*   ";
            lis[i] = lis[i].replace(/\s*<li[^>]*>([\s\S]*)/i, function (str, innerHTML) {

              innerHTML = innerHTML.replace(/^\s+/, '');
              innerHTML = innerHTML.replace(/\n\n/g, '\n\n    ');
              // indent nested lists
              innerHTML = innerHTML.replace(/\n([ ]*)+(\*|\d+\.) /g, '\n$1    $2 ');
              return prefix + innerHTML;
            });
          }
        }
        return lis.join('\n');
      });
      return '\n\n' + html.replace(/[ \t]+\n|\s+$/g, '');
    }

    // Blockquotes
    var deepest = /<blockquote\b[^>]*>((?:(?!<blockquote)[\s\S])*?)<\/blockquote>/gi;
    while (string.match(deepest)) {
      string = string.replace(deepest, function (str) {
        return replaceBlockquotes(str);
      });
    }

    function replaceBlockquotes(html) {
      html = html.replace(/<blockquote\b[^>]*>([\s\S]*?)<\/blockquote>/gi, function (str, inner) {
        inner = inner.replace(/^\s+|\s+$/g, '');
        inner = cleanUp(inner);
        inner = inner.replace(/^/gm, '> ');
        inner = inner.replace(/^(>([ \t]{2,}>)+)/gm, '> >');
        return inner;
      });
      return html;
    }

    function cleanUp(string) {
      string = string.replace(/^[\t\r\n]+|[\t\r\n]+$/g, ''); // trim leading/trailing whitespace
      string = string.replace(/\n\s+\n/g, '\n\n');
      string = string.replace(/\n{3,}/g, '\n\n'); // limit consecutive linebreaks to 2
      return string;
    }

    return cleanUp(string);
  };

  if (typeof exports === 'object') {
    exports.toMarkdown = toMarkdown;
  }
</script>
<script>
  /* ===================================================
   * bootstrap-markdown.js v2.10.0
   * http://github.com/toopay/bootstrap-markdown
   * ===================================================
   * Copyright 2013-2016 Taufan Aditya
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   * ========================================================== */

  (function (factory) {
    if (typeof define === "function" && define.amd) {
      //RequireJS
      define(["jquery"], factory);
    } else if (typeof exports === 'object') {
      //Backbone.js
      factory(require('jquery'));
    } else {
      //Jquery plugin
      factory(jQuery);
    }
  }(function ($) {
    "use strict"; // jshint ;_;

    /* MARKDOWN CLASS DEFINITION
     * ========================== */

    var Markdown = function (element, options) {
      // @TODO : remove this BC on next major release
      // @see : https://github.com/toopay/bootstrap-markdown/issues/109
      var opts = ['autofocus', 'savable', 'hideable', 'width',
        'height', 'resize', 'iconlibrary', 'language',
        'footer', 'fullscreen', 'hiddenButtons', 'disabledButtons'];
      $.each(opts, function (_, opt) {
        if (typeof $(element).data(opt) !== 'undefined') {
          options = typeof options == 'object' ? options : {}
          options[opt] = $(element).data(opt)
        }
      });
      // End BC

      // Class Properties
      this.$ns = 'bootstrap-markdown';
      this.$element = $(element);
      this.$editable = {el: null, type: null, attrKeys: [], attrValues: [], content: null};
      this.$options = $.extend(true, {}, $.fn.markdown.defaults, options, this.$element.data('options'));
      this.$oldContent = null;
      this.$isPreview = false;
      this.$isFullscreen = false;
      this.$editor = null;
      this.$textarea = null;
      this.$handler = [];
      this.$callback = [];
      this.$nextTab = [];

      this.showEditor();
    };

    Markdown.prototype = {

      constructor: Markdown

      , __alterButtons: function (name, alter) {
        var handler = this.$handler, isAll = (name == 'all'), that = this;

        $.each(handler, function (k, v) {
          var halt = true;
          if (isAll) {
            halt = false;
          } else {
            halt = v.indexOf(name) < 0;
          }

          if (halt === false) {
            alter(that.$editor.find('button[data-handler="' + v + '"]'));
          }
        });
      }

      , __buildButtons: function (buttonsArray, container) {
        var i,
          ns = this.$ns,
          handler = this.$handler,
          callback = this.$callback;

        for (i = 0; i < buttonsArray.length; i++) {
          // Build each group container
          var y, btnGroups = buttonsArray[i];
          for (y = 0; y < btnGroups.length; y++) {
            // Build each button group
            var z,
              buttons = btnGroups[y].data,
              btnGroupContainer = $('<div/>', {
                'class': 'btn-group'
              });

            for (z = 0; z < buttons.length; z++) {
              var button = buttons[z],
                buttonContainer, buttonIconContainer,
                buttonHandler = ns + '-' + button.name,
                buttonIcon = this.__getIcon(button.icon),
                btnText = button.btnText ? button.btnText : '',
                btnClass = button.btnClass ? button.btnClass : 'btn',
                tabIndex = button.tabIndex ? button.tabIndex : '-1',
                hotkey = typeof button.hotkey !== 'undefined' ? button.hotkey : '',
                hotkeyCaption = typeof jQuery.hotkeys !== 'undefined' && hotkey !== '' ? ' (' + hotkey + ')' : '';

              // Construct the button object
              buttonContainer = $('<button></button>');
              buttonContainer.text(' ' + this.__localize(btnText)).addClass('btn-default btn-sm').addClass(btnClass);
              if (btnClass.match(/btn\-(primary|success|info|warning|danger|link)/)) {
                buttonContainer.removeClass('btn-default');
              }
              buttonContainer.attr({
                'type': 'button',
                'title': this.__localize(button.title) + hotkeyCaption,
                'tabindex': tabIndex,
                'data-provider': ns,
                'data-handler': buttonHandler,
                'data-hotkey': hotkey
              });
              if (button.toggle === true) {
                buttonContainer.attr('data-toggle', 'button');
              }
              buttonIconContainer = $('<span/>');
              buttonIconContainer.addClass(buttonIcon);
              buttonIconContainer.prependTo(buttonContainer);

              // Attach the button object
              btnGroupContainer.append(buttonContainer);

              // Register handler and callback
              handler.push(buttonHandler);
              callback.push(button.callback);
            }

            // Attach the button group into container dom
            container.append(btnGroupContainer);
          }
        }

        return container;
      }
      , __setListener: function () {
        // Set size and resizable Properties
        var hasRows = typeof this.$textarea.attr('rows') !== 'undefined',
          maxRows = this.$textarea.val().split("\n").length > 5 ? this.$textarea.val().split("\n").length : '5',
          rowsVal = hasRows ? this.$textarea.attr('rows') : maxRows;

        this.$textarea.attr('rows', rowsVal);
        if (this.$options.resize) {
          this.$textarea.css('resize', this.$options.resize);
        }

        this.$textarea.on({
          'focus': $.proxy(this.focus, this),
          'keyup': $.proxy(this.keyup, this),
          'change': $.proxy(this.change, this),
          'select': $.proxy(this.select, this)
        });

        if (this.eventSupported('keydown')) {
          this.$textarea.on('keydown', $.proxy(this.keydown, this));
        }

        if (this.eventSupported('keypress')) {
          this.$textarea.on('keypress', $.proxy(this.keypress, this))
        }

        // Re-attach markdown data
        this.$textarea.data('markdown', this);
      }

      , __handle: function (e) {
        var target = $(e.currentTarget),
          handler = this.$handler,
          callback = this.$callback,
          handlerName = target.attr('data-handler'),
          callbackIndex = handler.indexOf(handlerName),
          callbackHandler = callback[callbackIndex];

        // Trigger the focusin
        $(e.currentTarget).focus();

        callbackHandler(this);

        // Trigger onChange for each button handle
        this.change(this);

        // Unless it was the save handler,
        // focusin the textarea
        if (handlerName.indexOf('cmdSave') < 0) {
          this.$textarea.focus();
        }

        e.preventDefault();
      }

      , __localize: function (string) {
        var messages = $.fn.markdown.messages,
          language = this.$options.language;
        if (
          typeof messages !== 'undefined' &&
          typeof messages[language] !== 'undefined' &&
          typeof messages[language][string] !== 'undefined'
        ) {
          return messages[language][string];
        }
        return string;
      }

      , __getIcon: function (src) {
        return typeof src == 'object' ? src[this.$options.iconlibrary] : src;
      }

      , setFullscreen: function (mode) {
        var $editor = this.$editor,
          $textarea = this.$textarea;

        if (mode === true) {
          $editor.addClass('md-fullscreen-mode');
          $('body').addClass('md-nooverflow');
          this.$options.onFullscreen(this);
        } else {
          $editor.removeClass('md-fullscreen-mode');
          $('body').removeClass('md-nooverflow');

          if (this.$isPreview == true) this.hidePreview().showPreview()
        }

        this.$isFullscreen = mode;
        $textarea.focus();
      }

      , showEditor: function () {
        var instance = this,
          textarea,
          ns = this.$ns,
          container = this.$element,
          originalHeigth = container.css('height'),
          originalWidth = container.css('width'),
          editable = this.$editable,
          handler = this.$handler,
          callback = this.$callback,
          options = this.$options,
          editor = $('<div/>', {
            'class': 'md-editor',
            click: function () {
              instance.focus();
            }
          });

        // Prepare the editor
        if (this.$editor === null) {
          // Create the panel
          var editorHeader = $('<div/>', {
            'class': 'md-header btn-toolbar'
          });

          // Merge the main & additional button groups together
          var allBtnGroups = [];
          if (options.buttons.length > 0) allBtnGroups = allBtnGroups.concat(options.buttons[0]);
          if (options.additionalButtons.length > 0) {
            // iterate the additional button groups
            $.each(options.additionalButtons[0], function (idx, buttonGroup) {

              // see if the group name of the addional group matches an existing group
              var matchingGroups = $.grep(allBtnGroups, function (allButtonGroup, allIdx) {
                return allButtonGroup.name === buttonGroup.name;
              });

              // if it matches add the addional buttons to that group, if not just add it to the all buttons group
              if (matchingGroups.length > 0) {
                matchingGroups[0].data = matchingGroups[0].data.concat(buttonGroup.data);
              } else {
                allBtnGroups.push(options.additionalButtons[0][idx]);
              }

            });
          }

          // Reduce and/or reorder the button groups
          if (options.reorderButtonGroups.length > 0) {
            allBtnGroups = allBtnGroups
              .filter(function (btnGroup) {
                return options.reorderButtonGroups.indexOf(btnGroup.name) > -1;
              })
              .sort(function (a, b) {
                if (options.reorderButtonGroups.indexOf(a.name) < options.reorderButtonGroups.indexOf(b.name)) return -1;
                if (options.reorderButtonGroups.indexOf(a.name) > options.reorderButtonGroups.indexOf(b.name)) return 1;
                return 0;
              });
          }

          // Build the buttons
          if (allBtnGroups.length > 0) {
            editorHeader = this.__buildButtons([allBtnGroups], editorHeader);
          }

          if (options.fullscreen.enable) {
            editorHeader.append('<div class="md-controls"><a class="md-control md-control-fullscreen" href="#"><span class="' + this.__getIcon(options.fullscreen.icons.fullscreenOn) + '"></span></a></div>').on('click', '.md-control-fullscreen', function (e) {
              e.preventDefault();
              instance.setFullscreen(true);
            });
          }

          editor.append(editorHeader);

          // Wrap the textarea
          if (container.is('textarea')) {
            container.before(editor);
            textarea = container;
            textarea.addClass('md-input');
            editor.append(textarea);
          } else {
            var rawContent = (typeof toMarkdown == 'function') ? toMarkdown(container.html()) : container.html(),
              currentContent = $.trim(rawContent);

            // This is some arbitrary content that could be edited
            textarea = $('<textarea/>', {
              'class': 'md-input',
              'val': currentContent
            });

            editor.append(textarea);

            // Save the editable
            editable.el = container;
            editable.type = container.prop('tagName').toLowerCase();
            editable.content = container.html();

            $(container[0].attributes).each(function () {
              editable.attrKeys.push(this.nodeName);
              editable.attrValues.push(this.nodeValue);
            });

            // Set editor to blocked the original container
            container.replaceWith(editor);
          }

          var editorFooter = $('<div/>', {
              'class': 'md-footer'
            }),
            createFooter = false,
            footer = '';
          // Create the footer if savable
          if (options.savable) {
            createFooter = true;
            var saveHandler = 'cmdSave';

            // Register handler and callback
            handler.push(saveHandler);
            callback.push(options.onSave);

            editorFooter.append('<button class="btn btn-success" data-provider="'
              + ns
              + '" data-handler="'
              + saveHandler
              + '"><i class="icon icon-white icon-ok"></i> '
              + this.__localize('Save')
              + '</button>');


          }

          footer = typeof options.footer === 'function' ? options.footer(this) : options.footer;

          if ($.trim(footer) !== '') {
            createFooter = true;
            editorFooter.append(footer);
          }

          if (createFooter) editor.append(editorFooter);

          // Set width
          if (options.width && options.width !== 'inherit') {
            if (jQuery.isNumeric(options.width)) {
              editor.css('display', 'table');
              textarea.css('width', options.width + 'px');
            } else {
              editor.addClass(options.width);
            }
          }

          // Set height
          if (options.height && options.height !== 'inherit') {
            if (jQuery.isNumeric(options.height)) {
              var height = options.height;
              if (editorHeader) height = Math.max(0, height - editorHeader.outerHeight());
              if (editorFooter) height = Math.max(0, height - editorFooter.outerHeight());
              textarea.css('height', height + 'px');
            } else {
              editor.addClass(options.height);
            }
          }

          // Reference
          this.$editor = editor;
          this.$textarea = textarea;
          this.$editable = editable;
          this.$oldContent = this.getContent();

          this.__setListener();

          // Set editor attributes, data short-hand API and listener
          this.$editor.attr('id', (new Date()).getTime());
          this.$editor.on('click', '[data-provider="bootstrap-markdown"]', $.proxy(this.__handle, this));

          if (this.$element.is(':disabled') || this.$element.is('[readonly]')) {
            this.$editor.addClass('md-editor-disabled');
            this.disableButtons('all');
          }

          if (this.eventSupported('keydown') && typeof jQuery.hotkeys === 'object') {
            editorHeader.find('[data-provider="bootstrap-markdown"]').each(function () {
              var $button = $(this),
                hotkey = $button.attr('data-hotkey');
              if (hotkey.toLowerCase() !== '') {
                textarea.bind('keydown', hotkey, function () {
                  $button.trigger('click');
                  return false;
                });
              }
            });
          }

          if (options.initialstate === 'preview') {
            this.showPreview();
          } else if (options.initialstate === 'fullscreen' && options.fullscreen.enable) {
            this.setFullscreen(true);
          }

        } else {
          this.$editor.show();
        }

        if (options.autofocus) {
          this.$textarea.focus();
          this.$editor.addClass('active');
        }

        if (options.fullscreen.enable && options.fullscreen !== false) {
          this.$editor.append('<div class="md-fullscreen-controls">'
            + '<a href="#" class="exit-fullscreen" title="Exit fullscreen"><span class="' + this.__getIcon(options.fullscreen.icons.fullscreenOff) + '">'
            + '</span></a>'
            + '</div>');
          this.$editor.on('click', '.exit-fullscreen', function (e) {
            e.preventDefault();
            instance.setFullscreen(false);
          });
        }

        // hide hidden buttons from options
        this.hideButtons(options.hiddenButtons);

        // disable disabled buttons from options
        this.disableButtons(options.disabledButtons);

        // Trigger the onShow hook
        options.onShow(this);

        return this;
      }

      , parseContent: function (val) {
        var content;

        // parse with supported markdown parser
        var val = val || this.$textarea.val();

        if (this.$options.parser) {
          content = this.$options.parser(val);
        } else if (typeof markdown == 'object') {
          content = markdown.toHTML(val);
        } else if (typeof marked == 'function') {
          content = marked(val);
        } else {
          content = val;
        }

        return content;
      }

      , showPreview: function () {
        var options = this.$options,
          container = this.$textarea,
          afterContainer = container.next(),
          replacementContainer = $('<div/>', {'class': 'md-preview', 'data-provider': 'markdown-preview'}),
          content,
          callbackContent;

        if (this.$isPreview == true) {
          // Avoid sequenced element creation on missused scenario
          // @see https://github.com/toopay/bootstrap-markdown/issues/170
          return this;
        }

        // Give flag that tell the editor enter preview mode
        this.$isPreview = true;
        // Disable all buttons
        this.disableButtons('all').enableButtons('cmdPreview');

        // Try to get the content from callback
        callbackContent = options.onPreview(this);
        // Set the content based from the callback content if string otherwise parse value from textarea
        content = typeof callbackContent == 'string' ? callbackContent : this.parseContent();

        // Build preview element
        replacementContainer.html(content);

        if (afterContainer && afterContainer.attr('class') == 'md-footer') {
          // If there is footer element, insert the preview container before it
          replacementContainer.insertBefore(afterContainer);
        } else {
          // Otherwise, just append it after textarea
          container.parent().append(replacementContainer);
        }

        // Set the preview element dimensions
        replacementContainer.css({
          width: container.outerWidth() + 'px',
          height: container.outerHeight() + 'px'
        });

        if (this.$options.resize) {
          replacementContainer.css('resize', this.$options.resize);
        }

        // Hide the last-active textarea
        container.hide();

        // Attach the editor instances
        replacementContainer.data('markdown', this);

        if (this.$element.is(':disabled') || this.$element.is('[readonly]')) {
          this.$editor.addClass('md-editor-disabled');
          this.disableButtons('all');
        }

        return this;
      }

      , hidePreview: function () {
        // Give flag that tell the editor quit preview mode
        this.$isPreview = false;

        // Obtain the preview container
        var container = this.$editor.find('div[data-provider="markdown-preview"]');

        // Remove the preview container
        container.remove();

        // Enable all buttons
        this.enableButtons('all');
        // Disable configured disabled buttons
        this.disableButtons(this.$options.disabledButtons);

        // Back to the editor
        this.$textarea.show();
        this.__setListener();

        return this;
      }

      , isDirty: function () {
        return this.$oldContent != this.getContent();
      }

      , getContent: function () {
        return this.$textarea.val();
      }

      , setContent: function (content) {
        this.$textarea.val(content);

        return this;
      }

      , findSelection: function (chunk) {
        var content = this.getContent(), startChunkPosition;

        if (startChunkPosition = content.indexOf(chunk), startChunkPosition >= 0 && chunk.length > 0) {
          var oldSelection = this.getSelection(), selection;

          this.setSelection(startChunkPosition, startChunkPosition + chunk.length);
          selection = this.getSelection();

          this.setSelection(oldSelection.start, oldSelection.end);

          return selection;
        } else {
          return null;
        }
      }

      , getSelection: function () {

        var e = this.$textarea[0];

        return (

          ('selectionStart' in e && function () {
            var l = e.selectionEnd - e.selectionStart;
            return {start: e.selectionStart, end: e.selectionEnd, length: l, text: e.value.substr(e.selectionStart, l)};
          }) ||

          /* browser not supported */
          function () {
            return null;
          }

        )();

      }

      , setSelection: function (start, end) {

        var e = this.$textarea[0];

        return (

          ('selectionStart' in e && function () {
            e.selectionStart = start;
            e.selectionEnd = end;
            return;
          }) ||

          /* browser not supported */
          function () {
            return null;
          }

        )();

      }

      , replaceSelection: function (text) {

        var e = this.$textarea[0];

        return (

          ('selectionStart' in e && function () {
            e.value = e.value.substr(0, e.selectionStart) + text + e.value.substr(e.selectionEnd, e.value.length);
            // Set cursor to the last replacement end
            e.selectionStart = e.value.length;
            return this;
          }) ||

          /* browser not supported */
          function () {
            e.value += text;
            return jQuery(e);
          }

        )();
      }

      , getNextTab: function () {
        // Shift the nextTab
        if (this.$nextTab.length === 0) {
          return null;
        } else {
          var nextTab, tab = this.$nextTab.shift();

          if (typeof tab == 'function') {
            nextTab = tab();
          } else if (typeof tab == 'object' && tab.length > 0) {
            nextTab = tab;
          }

          return nextTab;
        }
      }

      , setNextTab: function (start, end) {
        // Push new selection into nextTab collections
        if (typeof start == 'string') {
          var that = this;
          this.$nextTab.push(function () {
            return that.findSelection(start);
          });
        } else if (typeof start == 'number' && typeof end == 'number') {
          var oldSelection = this.getSelection();

          this.setSelection(start, end);
          this.$nextTab.push(this.getSelection());

          this.setSelection(oldSelection.start, oldSelection.end);
        }

        return;
      }

      , __parseButtonNameParam: function (names) {
        return typeof names == 'string' ?
          names.split(' ') :
          names;

      }

      , enableButtons: function (name) {
        var buttons = this.__parseButtonNameParam(name),
          that = this;

        $.each(buttons, function (i, v) {
          that.__alterButtons(buttons[i], function (el) {
            el.removeAttr('disabled');
          });
        });

        return this;
      }

      , disableButtons: function (name) {
        var buttons = this.__parseButtonNameParam(name),
          that = this;

        $.each(buttons, function (i, v) {
          that.__alterButtons(buttons[i], function (el) {
            el.attr('disabled', 'disabled');
          });
        });

        return this;
      }

      , hideButtons: function (name) {
        var buttons = this.__parseButtonNameParam(name),
          that = this;

        $.each(buttons, function (i, v) {
          that.__alterButtons(buttons[i], function (el) {
            el.addClass('hidden');
          });
        });

        return this;
      }

      , showButtons: function (name) {
        var buttons = this.__parseButtonNameParam(name),
          that = this;

        $.each(buttons, function (i, v) {
          that.__alterButtons(buttons[i], function (el) {
            el.removeClass('hidden');
          });
        });

        return this;
      }

      , eventSupported: function (eventName) {
        var isSupported = eventName in this.$element;
        if (!isSupported) {
          this.$element.setAttribute(eventName, 'return;');
          isSupported = typeof this.$element[eventName] === 'function';
        }
        return isSupported;
      }

      , keyup: function (e) {
        var blocked = false;
        switch (e.keyCode) {
          case 40: // down arrow
          case 38: // up arrow
          case 16: // shift
          case 17: // ctrl
          case 18: // alt
            break;

          case 9: // tab
            var nextTab;
            if (nextTab = this.getNextTab(), nextTab !== null) {
              // Get the nextTab if exists
              var that = this;
              setTimeout(function () {
                that.setSelection(nextTab.start, nextTab.end);
              }, 500);

              blocked = true;
            } else {
              // The next tab memory contains nothing...
              // check the cursor position to determine tab action
              var cursor = this.getSelection();

              if (cursor.start == cursor.end && cursor.end == this.getContent().length) {
                // The cursor already reach the end of the content
                blocked = false;
              } else {
                // Put the cursor to the end
                this.setSelection(this.getContent().length, this.getContent().length);

                blocked = true;
              }
            }

            break;

          case 13: // enter
            blocked = false;
            break;
          case 27: // escape
            if (this.$isFullscreen) this.setFullscreen(false);
            blocked = false;
            break;

          default:
            blocked = false;
        }

        if (blocked) {
          e.stopPropagation();
          e.preventDefault();
        }

        this.$options.onChange(this);
      }

      , change: function (e) {
        this.$options.onChange(this);
        return this;
      }
      , select: function (e) {
        this.$options.onSelect(this);
        return this;
      }
      , focus: function (e) {
        var options = this.$options,
          isHideable = options.hideable,
          editor = this.$editor;

        editor.addClass('active');

        // Blur other markdown(s)
        $(document).find('.md-editor').each(function () {
          if ($(this).attr('id') !== editor.attr('id')) {
            var attachedMarkdown;

            if (attachedMarkdown = $(this).find('textarea').data('markdown'),
              attachedMarkdown === null) {
              attachedMarkdown = $(this).find('div[data-provider="markdown-preview"]').data('markdown');
            }

            if (attachedMarkdown) {
              attachedMarkdown.blur();
            }
          }
        });

        // Trigger the onFocus hook
        options.onFocus(this);

        return this;
      }

      , blur: function (e) {
        var options = this.$options,
          isHideable = options.hideable,
          editor = this.$editor,
          editable = this.$editable;

        if (editor.hasClass('active') || this.$element.parent().length === 0) {
          editor.removeClass('active');

          if (isHideable) {
            // Check for editable elements
            if (editable.el !== null) {
              // Build the original element
              var oldElement = $('<' + editable.type + '/>'),
                content = this.getContent(),
                currentContent = this.parseContent(content);

              $(editable.attrKeys).each(function (k, v) {
                oldElement.attr(editable.attrKeys[k], editable.attrValues[k]);
              });

              // Get the editor content
              oldElement.html(currentContent);

              editor.replaceWith(oldElement);
            } else {
              editor.hide();
            }
          }

          // Trigger the onBlur hook
          options.onBlur(this);
        }

        return this;
      }

    };

    /* MARKDOWN PLUGIN DEFINITION
     * ========================== */

    var old = $.fn.markdown;

    $.fn.markdown = function (option) {
      return this.each(function () {
        var $this = $(this)
          , data = $this.data('markdown')
          , options = typeof option == 'object' && option;
        if (!data) $this.data('markdown', (data = new Markdown(this, options)))
      })
    };

    $.fn.markdown.messages = {};

    $.fn.markdown.defaults = {
      /* Editor Properties */
      autofocus: false,
      hideable: false,
      savable: false,
      width: 'inherit',
      height: 'inherit',
      resize: 'none',
      iconlibrary: 'glyph',
      language: 'en',
      initialstate: 'editor',
      parser: null,

      /* Buttons Properties */
      buttons: [
        [{
          name: 'groupFont',
          data: [{
            name: 'cmdBold',
            hotkey: 'Ctrl+B',
            title: 'Bold',
            icon: {glyph: 'glyphicon glyphicon-bold', fa: 'fa fa-bold', 'fa-3': 'icon-bold'},
            callback: function (e) {
              // Give/remove ** surround the selection
              var chunk, cursor, selected = e.getSelection(), content = e.getContent();

              if (selected.length === 0) {
                // Give extra word
                chunk = e.__localize('strong text');
              } else {
                chunk = selected.text;
              }

              // transform selection and set the cursor into chunked text
              if (content.substr(selected.start - 2, 2) === '**'
                && content.substr(selected.end, 2) === '**') {
                e.setSelection(selected.start - 2, selected.end + 2);
                e.replaceSelection(chunk);
                cursor = selected.start - 2;
              } else {
                e.replaceSelection('**' + chunk + '**');
                cursor = selected.start + 2;
              }

              // Set the cursor
              e.setSelection(cursor, cursor + chunk.length);
            }
          }, {
            name: 'cmdItalic',
            title: 'Italic',
            hotkey: 'Ctrl+I',
            icon: {glyph: 'glyphicon glyphicon-italic', fa: 'fa fa-italic', 'fa-3': 'icon-italic'},
            callback: function (e) {
              // Give/remove * surround the selection
              var chunk, cursor, selected = e.getSelection(), content = e.getContent();

              if (selected.length === 0) {
                // Give extra word
                chunk = e.__localize('emphasized text');
              } else {
                chunk = selected.text;
              }

              // transform selection and set the cursor into chunked text
              if (content.substr(selected.start - 1, 1) === '_'
                && content.substr(selected.end, 1) === '_') {
                e.setSelection(selected.start - 1, selected.end + 1);
                e.replaceSelection(chunk);
                cursor = selected.start - 1;
              } else {
                e.replaceSelection('_' + chunk + '_');
                cursor = selected.start + 1;
              }

              // Set the cursor
              e.setSelection(cursor, cursor + chunk.length);
            }
          }, {
            name: 'cmdHeading',
            title: 'Heading',
            hotkey: 'Ctrl+H',
            icon: {glyph: 'glyphicon glyphicon-header', fa: 'fa fa-header', 'fa-3': 'icon-font'},
            callback: function (e) {
              // Append/remove ### surround the selection
              var chunk, cursor, selected = e.getSelection(), content = e.getContent(), pointer, prevChar;

              if (selected.length === 0) {
                // Give extra word
                chunk = e.__localize('heading text');
              } else {
                chunk = selected.text + '\n';
              }

              // transform selection and set the cursor into chunked text
              if ((pointer = 4, content.substr(selected.start - pointer, pointer) === '### ')
                || (pointer = 3, content.substr(selected.start - pointer, pointer) === '###')) {
                e.setSelection(selected.start - pointer, selected.end);
                e.replaceSelection(chunk);
                cursor = selected.start - pointer;
              } else if (selected.start > 0 && (prevChar = content.substr(selected.start - 1, 1), !!prevChar && prevChar != '\n')) {
                e.replaceSelection('\n\n### ' + chunk);
                cursor = selected.start + 6;
              } else {
                // Empty string before element
                e.replaceSelection('### ' + chunk);
                cursor = selected.start + 4;
              }

              // Set the cursor
              e.setSelection(cursor, cursor + chunk.length);
            }
          }]
        }, {
          name: 'groupLink',
          data: [{
            name: 'cmdUrl',
            title: 'URL/Link',
            hotkey: 'Ctrl+L',
            icon: {glyph: 'glyphicon glyphicon-link', fa: 'fa fa-link', 'fa-3': 'icon-link'},
            callback: function (e) {
              // Give [] surround the selection and prepend the link
              var chunk, cursor, selected = e.getSelection(), content = e.getContent(), link;

              if (selected.length === 0) {
                // Give extra word
                chunk = e.__localize('enter link description here');
              } else {
                chunk = selected.text;
              }

              link = prompt(e.__localize('Insert Hyperlink'), 'http://');

              var urlRegex = new RegExp('^((http|https)://|(mailto:)|(//))[a-z0-9]', 'i');
              if (link !== null && link !== '' && link !== 'http://' && urlRegex.test(link)) {
                var sanitizedLink = $('<div>' + link + '</div>').text();

                // transform selection and set the cursor into chunked text
                e.replaceSelection('[' + chunk + '](' + sanitizedLink + ')');
                cursor = selected.start + 1;

                // Set the cursor
                e.setSelection(cursor, cursor + chunk.length);
              }
            }
          }, {
            name: 'cmdImage',
            title: 'Image',
            hotkey: 'Ctrl+G',
            icon: {glyph: 'glyphicon glyphicon-picture', fa: 'fa fa-picture-o', 'fa-3': 'icon-picture'},
            callback: function (e) {
              // Give ![] surround the selection and prepend the image link
              var chunk, cursor, selected = e.getSelection(), content = e.getContent(), link;

              if (selected.length === 0) {
                // Give extra word
                chunk = e.__localize('enter image description here');
              } else {
                chunk = selected.text;
              }

              link = prompt(e.__localize('Insert Image Hyperlink'), 'http://');

              var urlRegex = new RegExp('^((http|https)://|(//))[a-z0-9]', 'i');
              if (link !== null && link !== '' && link !== 'http://' && urlRegex.test(link)) {
                var sanitizedLink = $('<div>' + link + '</div>').text();

                // transform selection and set the cursor into chunked text
                e.replaceSelection('![' + chunk + '](' + sanitizedLink + ' "' + e.__localize('enter image title here') + '")');
                cursor = selected.start + 2;

                // Set the next tab
                e.setNextTab(e.__localize('enter image title here'));

                // Set the cursor
                e.setSelection(cursor, cursor + chunk.length);
              }
            }
          }]
        }, {
          name: 'groupMisc',
          data: [{
            name: 'cmdList',
            hotkey: 'Ctrl+U',
            title: 'Unordered List',
            icon: {glyph: 'glyphicon glyphicon-list', fa: 'fa fa-list', 'fa-3': 'icon-list-ul'},
            callback: function (e) {
              // Prepend/Give - surround the selection
              var chunk, cursor, selected = e.getSelection(), content = e.getContent();

              // transform selection and set the cursor into chunked text
              if (selected.length === 0) {
                // Give extra word
                chunk = e.__localize('list text here');

                e.replaceSelection('- ' + chunk);
                // Set the cursor
                cursor = selected.start + 2;
              } else {
                if (selected.text.indexOf('\n') < 0) {
                  chunk = selected.text;

                  e.replaceSelection('- ' + chunk);

                  // Set the cursor
                  cursor = selected.start + 2;
                } else {
                  var list = [];

                  list = selected.text.split('\n');
                  chunk = list[0];

                  $.each(list, function (k, v) {
                    list[k] = '- ' + v;
                  });

                  e.replaceSelection('\n\n' + list.join('\n'));

                  // Set the cursor
                  cursor = selected.start + 4;
                }
              }

              // Set the cursor
              e.setSelection(cursor, cursor + chunk.length);
            }
          },
            {
              name: 'cmdListO',
              hotkey: 'Ctrl+O',
              title: 'Ordered List',
              icon: {glyph: 'glyphicon glyphicon-th-list', fa: 'fa fa-list-ol', 'fa-3': 'icon-list-ol'},
              callback: function (e) {

                // Prepend/Give - surround the selection
                var chunk, cursor, selected = e.getSelection(), content = e.getContent();

                // transform selection and set the cursor into chunked text
                if (selected.length === 0) {
                  // Give extra word
                  chunk = e.__localize('list text here');
                  e.replaceSelection('1. ' + chunk);
                  // Set the cursor
                  cursor = selected.start + 3;
                } else {
                  if (selected.text.indexOf('\n') < 0) {
                    chunk = selected.text;

                    e.replaceSelection('1. ' + chunk);

                    // Set the cursor
                    cursor = selected.start + 3;
                  } else {
                    var list = [];

                    list = selected.text.split('\n');
                    chunk = list[0];

                    $.each(list, function (k, v) {
                      list[k] = '1. ' + v;
                    });

                    e.replaceSelection('\n\n' + list.join('\n'));

                    // Set the cursor
                    cursor = selected.start + 5;
                  }
                }

                // Set the cursor
                e.setSelection(cursor, cursor + chunk.length);
              }
            },
            {
              name: 'cmdCode',
              hotkey: 'Ctrl+K',
              title: 'Code',
              icon: {glyph: 'glyphicon glyphicon-asterisk', fa: 'fa fa-code', 'fa-3': 'icon-code'},
              callback: function (e) {
                // Give/remove ** surround the selection
                var chunk, cursor, selected = e.getSelection(), content = e.getContent();

                if (selected.length === 0) {
                  // Give extra word
                  chunk = e.__localize('code text here');
                } else {
                  chunk = selected.text;
                }

                // transform selection and set the cursor into chunked text
                if (content.substr(selected.start - 4, 4) === '```\n'
                  && content.substr(selected.end, 4) === '\n```') {
                  e.setSelection(selected.start - 4, selected.end + 4);
                  e.replaceSelection(chunk);
                  cursor = selected.start - 4;
                } else if (content.substr(selected.start - 1, 1) === '`'
                  && content.substr(selected.end, 1) === '`') {
                  e.setSelection(selected.start - 1, selected.end + 1);
                  e.replaceSelection(chunk);
                  cursor = selected.start - 1;
                } else if (content.indexOf('\n') > -1) {
                  e.replaceSelection('```\n' + chunk + '\n```');
                  cursor = selected.start + 4;
                } else {
                  e.replaceSelection('`' + chunk + '`');
                  cursor = selected.start + 1;
                }

                // Set the cursor
                e.setSelection(cursor, cursor + chunk.length);
              }
            },
            {
              name: 'cmdQuote',
              hotkey: 'Ctrl+Q',
              title: 'Quote',
              icon: {glyph: 'glyphicon glyphicon-comment', fa: 'fa fa-quote-left', 'fa-3': 'icon-quote-left'},
              callback: function (e) {
                // Prepend/Give - surround the selection
                var chunk, cursor, selected = e.getSelection(), content = e.getContent();

                // transform selection and set the cursor into chunked text
                if (selected.length === 0) {
                  // Give extra word
                  chunk = e.__localize('quote here');

                  e.replaceSelection('> ' + chunk);

                  // Set the cursor
                  cursor = selected.start + 2;
                } else {
                  if (selected.text.indexOf('\n') < 0) {
                    chunk = selected.text;

                    e.replaceSelection('> ' + chunk);

                    // Set the cursor
                    cursor = selected.start + 2;
                  } else {
                    var list = [];

                    list = selected.text.split('\n');
                    chunk = list[0];

                    $.each(list, function (k, v) {
                      list[k] = '> ' + v;
                    });

                    e.replaceSelection('\n\n' + list.join('\n'));

                    // Set the cursor
                    cursor = selected.start + 4;
                  }
                }

                // Set the cursor
                e.setSelection(cursor, cursor + chunk.length);
              }
            }]
        }, {
          name: 'groupUtil',
          data: [{
            name: 'cmdPreview',
            toggle: true,
            hotkey: 'Ctrl+P',
            title: 'Preview',
            btnText: 'Preview',
            btnClass: 'btn btn-primary btn-sm',
            icon: {glyph: 'glyphicon glyphicon-search', fa: 'fa fa-search', 'fa-3': 'icon-search'},
            callback: function (e) {
              // Check the preview mode and toggle based on this flag
              var isPreview = e.$isPreview, content;

              if (isPreview === false) {
                // Give flag that tell the editor enter preview mode
                e.showPreview();
              } else {
                e.hidePreview();
              }
            }
          }]
        }]
      ],
      additionalButtons: [], // Place to hook more buttons by code
      reorderButtonGroups: [],
      hiddenButtons: [], // Default hidden buttons
      disabledButtons: [], // Default disabled buttons
      footer: '',
      fullscreen: {
        enable: true,
        icons: {
          fullscreenOn: {
            fa: 'fa fa-expand',
            glyph: 'glyphicon glyphicon-fullscreen',
            'fa-3': 'icon-resize-full'
          },
          fullscreenOff: {
            fa: 'fa fa-compress',
            glyph: 'glyphicon glyphicon-fullscreen',
            'fa-3': 'icon-resize-small'
          }
        }
      },

      /* Events hook */
      onShow: function (e) {
      },
      onPreview: function (e) {
      },
      onSave: function (e) {
      },
      onBlur: function (e) {
      },
      onFocus: function (e) {
      },
      onChange: function (e) {
      },
      onFullscreen: function (e) {
      },
      onSelect: function (e) {
      }
    };

    $.fn.markdown.Constructor = Markdown;


    /* MARKDOWN NO CONFLICT
     * ==================== */

    $.fn.markdown.noConflict = function () {
      $.fn.markdown = old;
      return this;
    };

    /* MARKDOWN GLOBAL FUNCTION & DATA-API
     * ==================================== */
    var initMarkdown = function (el) {
      var $this = el;

      if ($this.data('markdown')) {
        $this.data('markdown').showEditor();
        return;
      }

      $this.markdown()
    };

    var blurNonFocused = function (e) {
      var $activeElement = $(document.activeElement);

      // Blur event
      $(document).find('.md-editor').each(function () {
        var $this = $(this),
          focused = $activeElement.closest('.md-editor')[0] === this,
          attachedMarkdown = $this.find('textarea').data('markdown') ||
            $this.find('div[data-provider="markdown-preview"]').data('markdown');

        if (attachedMarkdown && !focused) {
          attachedMarkdown.blur();
        }
      })
    };

    $(document)
      .on('click.markdown.data-api', '[data-provide="markdown-editable"]', function (e) {
        initMarkdown($(this));
        e.preventDefault();
      })
      .on('click focusin', function (e) {
        blurNonFocused(e);
      })
      .ready(function () {
        $('textarea[data-provide="markdown"]').each(function () {
          initMarkdown($(this));
        })
      });

  }));
</script>
<script>
  /**
   * French translation for bootstrap-markdown
   * Benot Bourgeois <bierdok@gmail.com>
   */
  (function ($) {
    $.fn.markdown.messages.fr = {
      'Bold': "Gras",
      'Italic': "Italique",
      'Heading': "Titre",
      'URL/Link': "Insrer un lien HTTP",
      'Image': "Insrer une image",
      'List': "Liste  puces",
      'Preview': "Prvisualiser",
      'strong text': "texte important",
      'emphasized text': "texte en italique",
      'heading text': "texte d'entte",
      'enter link description here': "entrez la description du lien ici",
      'Insert Hyperlink': "Insrez le lien hypertexte",
      'enter image description here': "entrez la description de l'image ici",
      'Insert Image Hyperlink': "Insrez le lien hypertexte de l'image",
      'enter image title here': "entrez le titre de l'image ici",
      'list text here': "texte  puce ici",
      'Save': "Sauvegarder",
      'Ordered List': "Liste ordonne",
      'Unordered List': "Liste dsordonne",
      'Quote': "Citation",
      'quote here': "Votre citation",
      'Code': "Code",
      'code text here': "crire du code ici"
    };
  }(jQuery));
</script>
<script src="//rawgit.com/jeresig/jquery.hotkeys/master/jquery.hotkeys.js"></script>
<script>
  $(function () {
    $('button[type="submit"]').click(function () {
      var form = $(this).parent(),
        formResult = [],
        res = $('<pre/>', {
          'class': 'prettyprint'
        })

      $.each(form.serializeArray(), function (k, v) {
        formResult.push(v.name + ' => ' + v.value)
      })

      res.html('\n' + formResult.join('\n\n') + '\n')
      form.replaceWith(res)

      return false
    })

    $('#target-editor-with-custom-buttons').markdown({
      additionalButtons: [
        [{
          name: 'groupCustom',
          data: [{
            name: 'cmdBeer',
            title: 'Beer',
            icon: 'glyphicon glyphicon-glass',
            callback: function (e) {
              // Replace selection with some drinks
              var chunk, cursor, selected = e.getSelection(), content = e.getContent(),
                drinks = ['Heinekken', 'Budweiser', 'Iron City', 'Amstel Light', 'Red Stripe', 'Smithwicks', 'Westvleteren', 'Sierra Nevada', 'Guinness', 'Corona', 'Calsberg'],
                index = Math.floor((Math.random() * 10) + 1)


              // Give random drink
              chunk = drinks[index]

              // transform selection and set the cursor into chunked text
              e.replaceSelection(chunk)
              cursor = selected.start

              // Set the cursor
              e.setSelection(cursor, cursor + chunk.length)
            }
          }]
        }]
      ]
    })

    $('#target-editor-twitter').markdown({
      hiddenButtons: 'cmdPreview',
      footer: '<div id="twitter-footer" class="well" style="display:none;"></div><small id="twitter-counter" class="text-success">140 character left</small>',
      onChange: function (e) {
        var content = e.parseContent(),
          content_length = (content.match(/\n/g) || []).length + content.length

        if (content == '') {
          $('#twitter-footer').hide()
        } else {
          $('#twitter-footer').show().html(content)
        }

        if (content_length > 140) {
          $('#twitter-counter').removeClass('text-success').addClass('text-danger').html(content_length - 140 + ' character surplus.')
        } else {
          $('#twitter-counter').removeClass('text-danger').addClass('text-success').html(140 - content_length + ' character left.')
        }
      }
    })

    $('#target-editor-with-custom-language').markdown({language: 'fr'})

    $('#target-fa-editor').markdown({iconlibrary: 'fa'})

    $('#editor-triger-init').click(function () {
      $('#target-editor').markdown({
        savable: true,
        onShow: function (e) {
          alert('Showing '
            + e.$textarea.prop('tagName').toLowerCase()
            + '#'
            + e.$textarea.attr('id')
            + ' as Markdown Editor...')
        },
        onPreview: function (e) {
          var previewContent

          if (e.isDirty()) {
            var originalContent = e.getContent()

            previewContent = 'Prepended text here...'
              + "\n"
              + originalContent
              + "\n"
              + 'Apended text here...'
          } else {
            previewContent = 'Default content'
          }

          return previewContent
        },
        onChange: function (e) {
          console.log('Changed!')
        },
        onSave: function (e) {
          alert('Saving "' + e.getContent() + '"...')
        },
        onFocus: function (e) {
          // Since focusin event will fired until the focusout
          // sometime we may want to only do something
          // when focus occurs in the first time only
          if (!$(e.$element).data('focused')) {
            alert('Focus triggered!')
            $(e.$element).data('focused', true)
          }
        },
        onBlur: function (e) {
          alert('Blur triggered!')

          // Remove focus flag
          $(e.$element).data('focused', null)
        }
      })

      $(this).hide()
      return false
    })
  })
</script>
</body>
</html>
